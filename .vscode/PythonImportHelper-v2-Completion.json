[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "environ",
        "importPath": "os",
        "description": "os",
        "isExtraImport": true,
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "GoogleBenchmark",
        "importPath": "libcxx.test.googlebenchmark",
        "description": "libcxx.test.googlebenchmark",
        "isExtraImport": true,
        "detail": "libcxx.test.googlebenchmark",
        "documentation": {}
    },
    {
        "label": "sys,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.",
        "description": "sys.",
        "detail": "sys.",
        "documentation": {}
    },
    {
        "label": "date",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "gdb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gdb",
        "description": "gdb",
        "detail": "gdb",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "dirname",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "libcxx.test.dsl",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "libcxx.test.dsl",
        "description": "libcxx.test.dsl",
        "detail": "libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "libcxx.test.dsl",
        "description": "libcxx.test.dsl",
        "isExtraImport": true,
        "detail": "libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "libcxx.test.dsl",
        "description": "libcxx.test.dsl",
        "isExtraImport": true,
        "detail": "libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "lit.LitConfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lit.LitConfig",
        "description": "lit.LitConfig",
        "detail": "lit.LitConfig",
        "documentation": {}
    },
    {
        "label": "lit.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lit.util",
        "description": "lit.util",
        "detail": "lit.util",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "libcxx.sym_check",
        "description": "libcxx.sym_check",
        "isExtraImport": true,
        "detail": "libcxx.sym_check",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "libcxx.sym_check",
        "description": "libcxx.sym_check",
        "isExtraImport": true,
        "detail": "libcxx.sym_check",
        "documentation": {}
    },
    {
        "label": "diff",
        "importPath": "libcxx.sym_check",
        "description": "libcxx.sym_check",
        "isExtraImport": true,
        "detail": "libcxx.sym_check",
        "documentation": {}
    },
    {
        "label": "util",
        "importPath": "libcxx.sym_check",
        "description": "libcxx.sym_check",
        "isExtraImport": true,
        "detail": "libcxx.sym_check",
        "documentation": {}
    },
    {
        "label": "distutils.spawn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "distutils.spawn",
        "description": "distutils.spawn",
        "detail": "distutils.spawn",
        "documentation": {}
    },
    {
        "label": "pprint",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pprint",
        "description": "pprint",
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "pformat",
        "importPath": "pprint",
        "description": "pprint",
        "isExtraImport": true,
        "detail": "pprint",
        "documentation": {}
    },
    {
        "label": "ast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ast",
        "description": "ast",
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "pkgutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pkgutil",
        "description": "pkgutil",
        "detail": "pkgutil",
        "documentation": {}
    },
    {
        "label": "pipes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pipes",
        "description": "pipes",
        "detail": "pipes",
        "documentation": {}
    },
    {
        "label": "shlex",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shlex",
        "description": "shlex",
        "detail": "shlex",
        "documentation": {}
    },
    {
        "label": "quote",
        "importPath": "shlex",
        "description": "shlex",
        "isExtraImport": true,
        "detail": "shlex",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "CXXCompiler",
        "importPath": "libcxx.compiler",
        "description": "libcxx.compiler",
        "isExtraImport": true,
        "detail": "libcxx.compiler",
        "documentation": {}
    },
    {
        "label": "make_target_info",
        "importPath": "libcxx.test.target_info",
        "description": "libcxx.test.target_info",
        "isExtraImport": true,
        "detail": "libcxx.test.target_info",
        "documentation": {}
    },
    {
        "label": "libcxx.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "libcxx.util",
        "description": "libcxx.util",
        "detail": "libcxx.util",
        "documentation": {}
    },
    {
        "label": "executeCommand",
        "importPath": "libcxx.util",
        "description": "libcxx.util",
        "isExtraImport": true,
        "detail": "libcxx.util",
        "documentation": {}
    },
    {
        "label": "libcxx.test.features",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "libcxx.test.features",
        "description": "libcxx.test.features",
        "detail": "libcxx.test.features",
        "documentation": {}
    },
    {
        "label": "_isMSVC",
        "importPath": "libcxx.test.features",
        "description": "libcxx.test.features",
        "isExtraImport": true,
        "detail": "libcxx.test.features",
        "documentation": {}
    },
    {
        "label": "libcxx.test.newconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "libcxx.test.newconfig",
        "description": "libcxx.test.newconfig",
        "detail": "libcxx.test.newconfig",
        "documentation": {}
    },
    {
        "label": "libcxx.test.params",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "libcxx.test.params",
        "description": "libcxx.test.params",
        "detail": "libcxx.test.params",
        "documentation": {}
    },
    {
        "label": "lit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lit",
        "description": "lit",
        "detail": "lit",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "libcxx.test.format",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "libcxx.test.format",
        "description": "libcxx.test.format",
        "detail": "libcxx.test.format",
        "documentation": {}
    },
    {
        "label": "lit.Test",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lit.Test",
        "description": "lit.Test",
        "detail": "lit.Test",
        "documentation": {}
    },
    {
        "label": "lit.TestRunner",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lit.TestRunner",
        "description": "lit.TestRunner",
        "detail": "lit.TestRunner",
        "documentation": {}
    },
    {
        "label": "lit.formats",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "lit.formats",
        "description": "lit.formats",
        "detail": "lit.formats",
        "documentation": {}
    },
    {
        "label": "TestFormat",
        "importPath": "lit.formats.base",
        "description": "lit.formats.base",
        "isExtraImport": true,
        "detail": "lit.formats.base",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "libcxx.sym_check.extract",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "libcxx.sym_check.extract",
        "description": "libcxx.sym_check.extract",
        "detail": "libcxx.sym_check.extract",
        "documentation": {}
    },
    {
        "label": "libcxx.sym_check.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "libcxx.sym_check.util",
        "description": "libcxx.sym_check.util",
        "detail": "libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "pathlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pathlib",
        "description": "pathlib",
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TextIO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "array",
        "importPath": "array",
        "description": "array",
        "isExtraImport": true,
        "detail": "array",
        "documentation": {}
    },
    {
        "label": "range",
        "importPath": "builtins",
        "description": "builtins",
        "isExtraImport": true,
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "reduce",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "posixpath",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "posixpath",
        "description": "posixpath",
        "detail": "posixpath",
        "documentation": {}
    },
    {
        "label": "tarfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tarfile",
        "description": "tarfile",
        "detail": "tarfile",
        "documentation": {}
    },
    {
        "label": "config.name",
        "kind": 5,
        "importPath": "src.libcxx.benchmarks.lit.cfg",
        "description": "src.libcxx.benchmarks.lit.cfg",
        "peekOfCode": "config.name = 'libc++ benchmarks'\nconfig.suffixes = []\nconfig.test_exec_root = os.path.join(config.libcxx_obj_root, 'benchmarks')\nconfig.test_source_root = config.test_exec_root\nconfig.test_format = GoogleBenchmark(test_sub_dirs='.',\n                                     test_suffix='.libcxx.out',\n                                     benchmark_args=config.benchmark_args)",
        "detail": "src.libcxx.benchmarks.lit.cfg",
        "documentation": {}
    },
    {
        "label": "config.suffixes",
        "kind": 5,
        "importPath": "src.libcxx.benchmarks.lit.cfg",
        "description": "src.libcxx.benchmarks.lit.cfg",
        "peekOfCode": "config.suffixes = []\nconfig.test_exec_root = os.path.join(config.libcxx_obj_root, 'benchmarks')\nconfig.test_source_root = config.test_exec_root\nconfig.test_format = GoogleBenchmark(test_sub_dirs='.',\n                                     test_suffix='.libcxx.out',\n                                     benchmark_args=config.benchmark_args)",
        "detail": "src.libcxx.benchmarks.lit.cfg",
        "documentation": {}
    },
    {
        "label": "config.test_exec_root",
        "kind": 5,
        "importPath": "src.libcxx.benchmarks.lit.cfg",
        "description": "src.libcxx.benchmarks.lit.cfg",
        "peekOfCode": "config.test_exec_root = os.path.join(config.libcxx_obj_root, 'benchmarks')\nconfig.test_source_root = config.test_exec_root\nconfig.test_format = GoogleBenchmark(test_sub_dirs='.',\n                                     test_suffix='.libcxx.out',\n                                     benchmark_args=config.benchmark_args)",
        "detail": "src.libcxx.benchmarks.lit.cfg",
        "documentation": {}
    },
    {
        "label": "config.test_source_root",
        "kind": 5,
        "importPath": "src.libcxx.benchmarks.lit.cfg",
        "description": "src.libcxx.benchmarks.lit.cfg",
        "peekOfCode": "config.test_source_root = config.test_exec_root\nconfig.test_format = GoogleBenchmark(test_sub_dirs='.',\n                                     test_suffix='.libcxx.out',\n                                     benchmark_args=config.benchmark_args)",
        "detail": "src.libcxx.benchmarks.lit.cfg",
        "documentation": {}
    },
    {
        "label": "config.test_format",
        "kind": 5,
        "importPath": "src.libcxx.benchmarks.lit.cfg",
        "description": "src.libcxx.benchmarks.lit.cfg",
        "peekOfCode": "config.test_format = GoogleBenchmark(test_sub_dirs='.',\n                                     test_suffix='.libcxx.out',\n                                     benchmark_args=config.benchmark_args)",
        "detail": "src.libcxx.benchmarks.lit.cfg",
        "documentation": {}
    },
    {
        "label": "#needs_sphinx",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#needs_sphinx = '1.0'\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = ['sphinx.ext.intersphinx', 'sphinx.ext.todo']\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# The suffix of source filenames.\nsource_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "extensions",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "extensions = ['sphinx.ext.intersphinx', 'sphinx.ext.todo']\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n# The suffix of source filenames.\nsource_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "templates_path",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "templates_path = ['_templates']\n# The suffix of source filenames.\nsource_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.\nproject = u'libc++'\ncopyright = u'2011-%d, LLVM Project' % date.today().year",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "source_suffix",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "source_suffix = '.rst'\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.\nproject = u'libc++'\ncopyright = u'2011-%d, LLVM Project' % date.today().year\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#source_encoding",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#source_encoding = 'utf-8-sig'\n# The master toctree document.\nmaster_doc = 'index'\n# General information about the project.\nproject = u'libc++'\ncopyright = u'2011-%d, LLVM Project' % date.today().year\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "master_doc",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "master_doc = 'index'\n# General information about the project.\nproject = u'libc++'\ncopyright = u'2011-%d, LLVM Project' % date.today().year\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '15.0'",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "project",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "project = u'libc++'\ncopyright = u'2011-%d, LLVM Project' % date.today().year\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '15.0'\n# The full version, including alpha/beta/rc tags.\nrelease = '15.0'",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "copyright",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "copyright = u'2011-%d, LLVM Project' % date.today().year\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '15.0'\n# The full version, including alpha/beta/rc tags.\nrelease = '15.0'\n# The language for content autogenerated by Sphinx. Refer to documentation",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "version = '15.0'\n# The full version, including alpha/beta/rc tags.\nrelease = '15.0'\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "release",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "release = '15.0'\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\ntoday_fmt = '%Y-%m-%d'\n# List of patterns, relative to source directory, that match files and",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#language",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#language = None\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\ntoday_fmt = '%Y-%m-%d'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['_build', 'Helpers']\n# The reST default role (used for this markup: `text`) to use for all documents.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#today",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#today = ''\n# Else, today_fmt is used as the format for a strftime call.\ntoday_fmt = '%Y-%m-%d'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['_build', 'Helpers']\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "today_fmt",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "today_fmt = '%Y-%m-%d'\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['_build', 'Helpers']\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "exclude_patterns",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "exclude_patterns = ['_build', 'Helpers']\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#default_role",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#default_role = None\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\nshow_authors = True\n# The name of the Pygments (syntax highlighting) style to use.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#add_function_parentheses",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#add_function_parentheses = True\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\nshow_authors = True\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'friendly'\n# A list of ignored prefixes for module index sorting.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#add_module_names",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#add_module_names = True\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\nshow_authors = True\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'friendly'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# -- Options for HTML output ---------------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "show_authors",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "show_authors = True\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'friendly'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# -- Options for HTML output ---------------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'haiku'\n# Theme options are theme-specific and customize the look and feel of a theme",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "pygments_style",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "pygments_style = 'friendly'\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n# -- Options for HTML output ---------------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'haiku'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#modindex_common_prefix",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#modindex_common_prefix = []\n# -- Options for HTML output ---------------------------------------------------\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'haiku'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n# Add any paths that contain custom themes here, relative to this directory.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_theme",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "html_theme = 'haiku'\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_theme_options",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_theme_options = {}\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_theme_path",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_theme_path = []\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_title",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_title = None\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_short_title",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_short_title = None\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_logo",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_logo = None\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = []\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_favicon",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_favicon = None\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = []\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "html_static_path",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "html_static_path = []\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_last_updated_fmt",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_last_updated_fmt = '%b %d, %Y'\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n# If false, no module index is generated.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_smartypants",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_use_smartypants = True\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n# If false, no module index is generated.\n#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_sidebars",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_sidebars = {}\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n# If false, no module index is generated.\n#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_additional_pages",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_additional_pages = {}\n# If false, no module index is generated.\n#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_domain_indices",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_domain_indices = True\n# If false, no index is generated.\n#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_index",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_use_index = True\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_split_index",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_split_index = False\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_show_sourcelink",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_show_sourcelink = True\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_show_sphinx",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_show_sphinx = True\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n# Output file base name for HTML help builder.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_show_copyright",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_show_copyright = True\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'libcxxdoc'\n# -- Options for LaTeX output --------------------------------------------------",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_use_opensearch",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_use_opensearch = ''\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'libcxxdoc'\n# -- Options for LaTeX output --------------------------------------------------\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n# The font size ('10pt', '11pt' or '12pt').",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#html_file_suffix",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#html_file_suffix = None\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'libcxxdoc'\n# -- Options for LaTeX output --------------------------------------------------\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n# Additional stuff for the LaTeX preamble.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "htmlhelp_basename",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "htmlhelp_basename = 'libcxxdoc'\n# -- Options for LaTeX output --------------------------------------------------\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n# Additional stuff for the LaTeX preamble.\n#'preamble': '',\n}",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "latex_elements",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "latex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n# Additional stuff for the LaTeX preamble.\n#'preamble': '',\n}\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "latex_documents",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "latex_documents = [\n  ('contents', 'libcxx.tex', u'libcxx Documentation',\n   u'LLVM project', 'manual'),\n]\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_logo",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#latex_logo = None\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_use_parts",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#latex_use_parts = False\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output --------------------------------------------",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_show_pagerefs",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#latex_show_pagerefs = False\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output --------------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_show_urls",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#latex_show_urls = False\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output --------------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('contents', 'libc++', u'libc++ Documentation',",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_appendices",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#latex_appendices = []\n# If false, no module index is generated.\n#latex_domain_indices = True\n# -- Options for manual page output --------------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('contents', 'libc++', u'libc++ Documentation',\n     [u'LLVM project'], 1)\n]",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#latex_domain_indices",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#latex_domain_indices = True\n# -- Options for manual page output --------------------------------------------\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('contents', 'libc++', u'libc++ Documentation',\n     [u'LLVM project'], 1)\n]\n# If true, show URL addresses after external links.\n#man_show_urls = False",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "man_pages",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "man_pages = [\n    ('contents', 'libc++', u'libc++ Documentation',\n     [u'LLVM project'], 1)\n]\n# If true, show URL addresses after external links.\n#man_show_urls = False\n# -- Options for Texinfo output ------------------------------------------------\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#man_show_urls",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#man_show_urls = False\n# -- Options for Texinfo output ------------------------------------------------\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  ('contents', 'libc++', u'libc++ Documentation',\n   u'LLVM project', 'libc++', 'One line description of project.',\n   'Miscellaneous'),\n]",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "texinfo_documents",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "texinfo_documents = [\n  ('contents', 'libc++', u'libc++ Documentation',\n   u'LLVM project', 'libc++', 'One line description of project.',\n   'Miscellaneous'),\n]\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n# How to display URL addresses: 'footnote', 'no', or 'inline'.",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#texinfo_appendices",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#texinfo_appendices = []\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n# FIXME: Define intersphinx configuration.\nintersphinx_mapping = {}\n# -- Options for extensions ----------------------------------------------------\n# Enable this if you want TODOs to show up in the generated documentation.\ntodo_include_todos = True",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#texinfo_domain_indices",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#texinfo_domain_indices = True\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n# FIXME: Define intersphinx configuration.\nintersphinx_mapping = {}\n# -- Options for extensions ----------------------------------------------------\n# Enable this if you want TODOs to show up in the generated documentation.\ntodo_include_todos = True",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "#texinfo_show_urls",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "#texinfo_show_urls = 'footnote'\n# FIXME: Define intersphinx configuration.\nintersphinx_mapping = {}\n# -- Options for extensions ----------------------------------------------------\n# Enable this if you want TODOs to show up in the generated documentation.\ntodo_include_todos = True",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "intersphinx_mapping",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "intersphinx_mapping = {}\n# -- Options for extensions ----------------------------------------------------\n# Enable this if you want TODOs to show up in the generated documentation.\ntodo_include_todos = True",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "todo_include_todos",
        "kind": 5,
        "importPath": "src.libcxx.docs.conf",
        "description": "src.libcxx.docs.conf",
        "peekOfCode": "todo_include_todos = True",
        "detail": "src.libcxx.docs.conf",
        "documentation": {}
    },
    {
        "label": "CheckResult",
        "kind": 6,
        "importPath": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "description": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "peekOfCode": "class CheckResult(gdb.Command):\n    def __init__(self):\n        super(CheckResult, self).__init__(\n            \"print_and_compare\", gdb.COMMAND_DATA)\n    def invoke(self, arg, from_tty):\n        global has_run_tests\n        try:\n            has_run_tests = True\n            # Stack frame is:\n            # 0. StopForDebugger",
        "detail": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "documentation": {}
    },
    {
        "label": "exit_handler",
        "kind": 2,
        "importPath": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "description": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "peekOfCode": "def exit_handler(event=None):\n    global test_failures\n    global has_run_tests\n    if not has_run_tests:\n        print(\"FAILED test program did not run correctly, check gdb warnings\")\n        test_failures = -1\n    elif test_failures:\n        print(\"FAILED %d cases\" % test_failures)\n    exit(test_failures)\n# Start code executed at load time",
        "detail": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "documentation": {}
    },
    {
        "label": "test_failures",
        "kind": 5,
        "importPath": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "description": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "peekOfCode": "test_failures = 0\n# Sometimes the inital run command can fail to trace the process.\n# (e.g. you don't have ptrace permissions)\n# In these cases gdb still sends us an exited event so we cannot\n# see what \"run\" printed to check for a warning message, since\n# we get taken to our exit handler before we can look.\n# Instead check that at least one test has been run by the time\n# we exit.\nhas_run_tests = False\nclass CheckResult(gdb.Command):",
        "detail": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "documentation": {}
    },
    {
        "label": "has_run_tests",
        "kind": 5,
        "importPath": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "description": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "peekOfCode": "has_run_tests = False\nclass CheckResult(gdb.Command):\n    def __init__(self):\n        super(CheckResult, self).__init__(\n            \"print_and_compare\", gdb.COMMAND_DATA)\n    def invoke(self, arg, from_tty):\n        global has_run_tests\n        try:\n            has_run_tests = True\n            # Stack frame is:",
        "detail": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "documentation": {}
    },
    {
        "label": "test_failures",
        "kind": 5,
        "importPath": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "description": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "peekOfCode": "test_failures = 0\nCheckResult()\ntest_bp = gdb.Breakpoint(\"StopForDebugger\")\ntest_bp.enabled = True\ntest_bp.silent = True\ntest_bp.commands = \"print_and_compare\\ncontinue\"\n# \"run\" won't return if the program exits; ensure the script regains control.\ngdb.events.exited.connect(exit_handler)\ngdb.execute(\"run\")\n# If the program didn't exit, something went wrong, but we don't",
        "detail": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "documentation": {}
    },
    {
        "label": "test_bp",
        "kind": 5,
        "importPath": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "description": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "peekOfCode": "test_bp = gdb.Breakpoint(\"StopForDebugger\")\ntest_bp.enabled = True\ntest_bp.silent = True\ntest_bp.commands = \"print_and_compare\\ncontinue\"\n# \"run\" won't return if the program exits; ensure the script regains control.\ngdb.events.exited.connect(exit_handler)\ngdb.execute(\"run\")\n# If the program didn't exit, something went wrong, but we don't\n# know what. Fail on exit.\ntest_failures += 1",
        "detail": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "documentation": {}
    },
    {
        "label": "test_bp.enabled",
        "kind": 5,
        "importPath": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "description": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "peekOfCode": "test_bp.enabled = True\ntest_bp.silent = True\ntest_bp.commands = \"print_and_compare\\ncontinue\"\n# \"run\" won't return if the program exits; ensure the script regains control.\ngdb.events.exited.connect(exit_handler)\ngdb.execute(\"run\")\n# If the program didn't exit, something went wrong, but we don't\n# know what. Fail on exit.\ntest_failures += 1\nexit_handler(None)",
        "detail": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "documentation": {}
    },
    {
        "label": "test_bp.silent",
        "kind": 5,
        "importPath": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "description": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "peekOfCode": "test_bp.silent = True\ntest_bp.commands = \"print_and_compare\\ncontinue\"\n# \"run\" won't return if the program exits; ensure the script regains control.\ngdb.events.exited.connect(exit_handler)\ngdb.execute(\"run\")\n# If the program didn't exit, something went wrong, but we don't\n# know what. Fail on exit.\ntest_failures += 1\nexit_handler(None)",
        "detail": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "documentation": {}
    },
    {
        "label": "test_bp.commands",
        "kind": 5,
        "importPath": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "description": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "peekOfCode": "test_bp.commands = \"print_and_compare\\ncontinue\"\n# \"run\" won't return if the program exits; ensure the script regains control.\ngdb.events.exited.connect(exit_handler)\ngdb.execute(\"run\")\n# If the program didn't exit, something went wrong, but we don't\n# know what. Fail on exit.\ntest_failures += 1\nexit_handler(None)",
        "detail": "src.libcxx.test.libcxx.gdb.gdb_pretty_printer_test",
        "documentation": {}
    },
    {
        "label": "exclude_from_consideration",
        "kind": 2,
        "importPath": "src.libcxx.test.libcxx.lint.lint_headers.sh",
        "description": "src.libcxx.test.libcxx.lint.lint_headers.sh",
        "peekOfCode": "def exclude_from_consideration(path):\n    return (\n        path.endswith('.txt') or\n        path.endswith('.modulemap.in') or\n        os.path.basename(path) == '__config' or\n        os.path.basename(path) == '__config_site.in' or\n        not os.path.isfile(path)\n    )\ndef check_for_pragma_GCC_system_header(pretty_fname, lines):\n    if pretty_fname not in ['__undef_macros']:",
        "detail": "src.libcxx.test.libcxx.lint.lint_headers.sh",
        "documentation": {}
    },
    {
        "label": "check_for_pragma_GCC_system_header",
        "kind": 2,
        "importPath": "src.libcxx.test.libcxx.lint.lint_headers.sh",
        "description": "src.libcxx.test.libcxx.lint.lint_headers.sh",
        "peekOfCode": "def check_for_pragma_GCC_system_header(pretty_fname, lines):\n    if pretty_fname not in ['__undef_macros']:\n        for line in lines:\n            if re.match('# *pragma GCC system_header\\n', line):\n                return True\n        print('FAILED TO FIND #  pragma GCC system_header in libcxx/include/%s' % pretty_fname)\n        return False\n    return True\nif __name__ == '__main__':\n    libcxx_test_libcxx_lint = os.path.dirname(os.path.abspath(__file__))",
        "detail": "src.libcxx.test.libcxx.lint.lint_headers.sh",
        "documentation": {}
    },
    {
        "label": "SetupConfigs",
        "kind": 6,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "class SetupConfigs(unittest.TestCase):\n    \"\"\"\n    Base class for the tests below -- it creates a fake TestingConfig.\n    \"\"\"\n    def setUp(self):\n        \"\"\"\n        Create a fake TestingConfig that can be populated however we wish for\n        the purpose of running unit tests below. We pre-populate it with the\n        minimum required substitutions.\n        \"\"\"",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "TestHasCompileFlag",
        "kind": 6,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "class TestHasCompileFlag(SetupConfigs):\n    \"\"\"\n    Tests for libcxx.test.dsl.hasCompileFlag\n    \"\"\"\n    def test_no_flag_should_work(self):\n        self.assertTrue(dsl.hasCompileFlag(self.config, ''))\n    def test_flag_exists(self):\n        self.assertTrue(dsl.hasCompileFlag(self.config, '-O1'))\n    def test_nonexistent_flag(self):\n        self.assertFalse(dsl.hasCompileFlag(self.config, '-this_is_not_a_flag_any_compiler_has'))",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "TestSourceBuilds",
        "kind": 6,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "class TestSourceBuilds(SetupConfigs):\n    \"\"\"\n    Tests for libcxx.test.dsl.sourceBuilds\n    \"\"\"\n    def test_valid_program_builds(self):\n        source = \"\"\"int main(int, char**) { return 0; }\"\"\"\n        self.assertTrue(dsl.sourceBuilds(self.config, source))\n    def test_compilation_error_fails(self):\n        source = \"\"\"int main(int, char**) { this does not compile }\"\"\"\n        self.assertFalse(dsl.sourceBuilds(self.config, source))",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "TestProgramOutput",
        "kind": 6,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "class TestProgramOutput(SetupConfigs):\n    \"\"\"\n    Tests for libcxx.test.dsl.programOutput\n    \"\"\"\n    def test_valid_program_returns_output(self):\n        source = \"\"\"\n        #include <cstdio>\n        int main(int, char**) { std::printf(\"FOOBAR\"); return 0; }\n        \"\"\"\n        self.assertEqual(dsl.programOutput(self.config, source), \"FOOBAR\")",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "TestProgramSucceeds",
        "kind": 6,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "class TestProgramSucceeds(SetupConfigs):\n    \"\"\"\n    Tests for libcxx.test.dsl.programSucceeds\n    \"\"\"\n    def test_success(self):\n        source = \"\"\"\n        int main(int, char**) { return 0; }\n        \"\"\"\n        self.assertTrue(dsl.programSucceeds(self.config, source))\n    def test_failure(self):",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "TestHasLocale",
        "kind": 6,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "class TestHasLocale(SetupConfigs):\n    \"\"\"\n    Tests for libcxx.test.dsl.hasLocale\n    \"\"\"\n    def test_doesnt_explode(self):\n        # It's really hard to test that a system has a given locale, so at least\n        # make sure we don't explode when we try to check it.\n        try:\n            dsl.hasAnyLocale(self.config, ['en_US.UTF-8'])\n        except subprocess.CalledProcessError:",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "TestCompilerMacros",
        "kind": 6,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "class TestCompilerMacros(SetupConfigs):\n    \"\"\"\n    Tests for libcxx.test.dsl.compilerMacros\n    \"\"\"\n    def test_basic(self):\n        macros = dsl.compilerMacros(self.config)\n        self.assertIsInstance(macros, dict)\n        self.assertGreater(len(macros), 0)\n        for (k, v) in macros.items():\n            self.assertIsInstance(k, str)",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "TestFeatureTestMacros",
        "kind": 6,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "class TestFeatureTestMacros(SetupConfigs):\n    \"\"\"\n    Tests for libcxx.test.dsl.featureTestMacros\n    \"\"\"\n    def test_basic(self):\n        macros = dsl.featureTestMacros(self.config)\n        self.assertIsInstance(macros, dict)\n        self.assertGreater(len(macros), 0)\n        for (k, v) in macros.items():\n            self.assertIsInstance(k, str)",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "TestFeature",
        "kind": 6,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "class TestFeature(SetupConfigs):\n    \"\"\"\n    Tests for libcxx.test.dsl.Feature\n    \"\"\"\n    def test_trivial(self):\n        feature = dsl.Feature(name='name')\n        origSubstitutions = copy.deepcopy(self.config.substitutions)\n        actions = feature.getActions(self.config)\n        self.assertTrue(len(actions) == 1)\n        for a in actions:",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "TestParameter",
        "kind": 6,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "class TestParameter(SetupConfigs):\n    \"\"\"\n    Tests for libcxx.test.dsl.Parameter\n    \"\"\"\n    def test_empty_name_should_blow_up(self):\n        self.assertRaises(ValueError, lambda: dsl.Parameter(name='', choices=['c++03'], type=str, help='', actions=lambda _: []))\n    def test_empty_choices_should_blow_up(self):\n        self.assertRaises(ValueError, lambda: dsl.Parameter(name='std', choices=[], type=str, help='', actions=lambda _: []))\n    def test_no_choices_is_ok(self):\n        param = dsl.Parameter(name='triple', type=str, help='', actions=lambda _: [])",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "findIndex",
        "kind": 2,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "def findIndex(list, pred):\n    \"\"\"Finds the index of the first element satisfying 'pred' in a list, or\n       'len(list)' if there is no such element.\"\"\"\n    index = 0\n    for x in list:\n        if pred(x):\n            break\n        else:\n            index += 1\n    return index",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "monorepoRoot",
        "kind": 5,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "monorepoRoot = dirname(dirname(dirname(dirname(dirname(dirname(__file__))))))\nsys.path = [os.path.join(monorepoRoot, 'libcxx', 'utils'),\n            os.path.join(monorepoRoot, 'llvm', 'utils', 'lit')] + sys.path\nimport libcxx.test.dsl as dsl\nimport lit.LitConfig\nimport lit.util\n# Steal some parameters from the config running this test so that we can\n# bootstrap our own TestingConfig.\nargs = list(map(lambda s: s[1:], sys.argv[1:8])) # Remove the leading 'x'\nSOURCE_ROOT, EXEC_PATH, SUBSTITUTIONS = args",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "sys.path",
        "kind": 5,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "sys.path = [os.path.join(monorepoRoot, 'libcxx', 'utils'),\n            os.path.join(monorepoRoot, 'llvm', 'utils', 'lit')] + sys.path\nimport libcxx.test.dsl as dsl\nimport lit.LitConfig\nimport lit.util\n# Steal some parameters from the config running this test so that we can\n# bootstrap our own TestingConfig.\nargs = list(map(lambda s: s[1:], sys.argv[1:8])) # Remove the leading 'x'\nSOURCE_ROOT, EXEC_PATH, SUBSTITUTIONS = args\nsys.argv[1:8] = []",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "args = list(map(lambda s: s[1:], sys.argv[1:8])) # Remove the leading 'x'\nSOURCE_ROOT, EXEC_PATH, SUBSTITUTIONS = args\nsys.argv[1:8] = []\n# Decode the substitutions.\nSUBSTITUTIONS = pickle.loads(base64.b64decode(SUBSTITUTIONS))\nfor s, sub in SUBSTITUTIONS:\n    print(\"Substitution '{}' is '{}'\".format(s, sub))\nclass SetupConfigs(unittest.TestCase):\n    \"\"\"\n    Base class for the tests below -- it creates a fake TestingConfig.",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "sys.argv[1:8]",
        "kind": 5,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "sys.argv[1:8] = []\n# Decode the substitutions.\nSUBSTITUTIONS = pickle.loads(base64.b64decode(SUBSTITUTIONS))\nfor s, sub in SUBSTITUTIONS:\n    print(\"Substitution '{}' is '{}'\".format(s, sub))\nclass SetupConfigs(unittest.TestCase):\n    \"\"\"\n    Base class for the tests below -- it creates a fake TestingConfig.\n    \"\"\"\n    def setUp(self):",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "SUBSTITUTIONS",
        "kind": 5,
        "importPath": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "description": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "peekOfCode": "SUBSTITUTIONS = pickle.loads(base64.b64decode(SUBSTITUTIONS))\nfor s, sub in SUBSTITUTIONS:\n    print(\"Substitution '{}' is '{}'\".format(s, sub))\nclass SetupConfigs(unittest.TestCase):\n    \"\"\"\n    Base class for the tests below -- it creates a fake TestingConfig.\n    \"\"\"\n    def setUp(self):\n        \"\"\"\n        Create a fake TestingConfig that can be populated however we wish for",
        "detail": "src.libcxx.test.libcxx.selftest.dsl.dsl.sh",
        "documentation": {}
    },
    {
        "label": "headers",
        "kind": 5,
        "importPath": "src.libcxx.test.libcxx.transitive_includes.sanitize",
        "description": "src.libcxx.test.libcxx.transitive_includes.sanitize",
        "peekOfCode": "headers = []\nfor line in sys.stdin.readlines():\n  match = re.search('c\\+\\+/v[0-9]+/(.+)', line)\n  if not match:\n    continue\n  header = match.group(1)\n  if os.path.basename(header).endswith('.h'): # Skip C headers\n    continue\n  if os.path.basename(header).startswith('__'): # Skip internal headers\n    continue",
        "detail": "src.libcxx.test.libcxx.transitive_includes.sanitize",
        "documentation": {}
    },
    {
        "label": "StdTuplePrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdTuplePrinter(object):\n    \"\"\"Print a std::tuple.\"\"\"\n    class _Children(object):\n        \"\"\"Class to iterate over the tuple's children.\"\"\"\n        def __init__(self, val):\n            self.val = val\n            self.child_iter = iter(self.val[\"__base_\"].type.fields())\n            self.count = 0\n        def __iter__(self):\n            return self",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdStringPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdStringPrinter(object):\n    \"\"\"Print a std::string.\"\"\"\n    def __init__(self, val):\n        self.val = val\n    def to_string(self):\n        \"\"\"Build a python string from the data whether stored inline or separately.\"\"\"\n        value_field = _value_of_pair_first(self.val[\"__r_\"])\n        short_field = value_field[\"__s\"]\n        short_size = short_field[\"__size_\"]\n        if short_size == 0:",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdStringViewPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdStringViewPrinter(object):\n    \"\"\"Print a std::string_view.\"\"\"\n    def __init__(self, val):\n      self.val = val\n    def display_hint(self):\n      return \"string\"\n    def to_string(self):  # pylint: disable=g-bad-name\n      \"\"\"GDB calls this to compute the pretty-printed form.\"\"\"\n      ptr = self.val[\"__data\"]\n      ptr = ptr.cast(ptr.type.target().strip_typedefs().pointer())",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdUniquePtrPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdUniquePtrPrinter(object):\n    \"\"\"Print a std::unique_ptr.\"\"\"\n    def __init__(self, val):\n        self.val = val\n        self.addr = _value_of_pair_first(self.val[\"__ptr_\"])\n        self.pointee_type = self.val.type.template_argument(0)\n    def to_string(self):\n        typename = _remove_generics(_prettify_typename(self.val.type))\n        if not self.addr:\n            return \"%s is nullptr\" % typename",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdSharedPointerPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdSharedPointerPrinter(object):\n    \"\"\"Print a std::shared_ptr.\"\"\"\n    def __init__(self, val):\n        self.val = val\n        self.addr = self.val[\"__ptr_\"]\n    def to_string(self):\n        \"\"\"Returns self as a string.\"\"\"\n        typename = _remove_generics(_prettify_typename(self.val.type))\n        pointee_type = _remove_generics(\n            _prettify_typename(self.val.type.template_argument(0)))",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdVectorPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdVectorPrinter(object):\n    \"\"\"Print a std::vector.\"\"\"\n    class _VectorBoolIterator(object):\n        \"\"\"Class to iterate over the bool vector's children.\"\"\"\n        def __init__(self, begin, size, bits_per_word):\n            self.item = begin\n            self.size = size\n            self.bits_per_word = bits_per_word\n            self.count = 0\n            self.offset = 0",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdBitsetPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdBitsetPrinter(object):\n    \"\"\"Print a std::bitset.\"\"\"\n    def __init__(self, val):\n        self.val = val\n        self.n_words = int(self.val[\"__n_words\"])\n        self.bits_per_word = int(self.val[\"__bits_per_word\"])\n        self.bit_count = self.val.type.template_argument(0)\n        if self.n_words == 1:\n            self.values = [int(self.val[\"__first_\"])]\n        else:",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdDequePrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdDequePrinter(object):\n    \"\"\"Print a std::deque.\"\"\"\n    def __init__(self, val):\n        self.val = val\n        self.size = int(_value_of_pair_first(val[\"__size_\"]))\n        self.start_ptr = self.val[\"__map_\"][\"__begin_\"]\n        self.first_block_start_index = int(self.val[\"__start_\"])\n        self.node_type = self.start_ptr.type\n        self.block_size = self._calculate_block_size(\n            val.type.template_argument(0))",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdListPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdListPrinter(object):\n    \"\"\"Print a std::list.\"\"\"\n    def __init__(self, val):\n        self.val = val\n        size_alloc_field = self.val[\"__size_alloc_\"]\n        self.size = int(_value_of_pair_first(size_alloc_field))\n        dummy_node = self.val[\"__end_\"]\n        self.nodetype = gdb.lookup_type(\n            re.sub(\"__list_node_base\", \"__list_node\",\n                   str(dummy_node.type.strip_typedefs()))).pointer()",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdQueueOrStackPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdQueueOrStackPrinter(object):\n    \"\"\"Print a std::queue or std::stack.\"\"\"\n    def __init__(self, val):\n        self.val = val\n        self.underlying = val[\"c\"]\n    def to_string(self):\n        typename = _remove_generics(_prettify_typename(self.val.type))\n        return \"%s wrapping\" % typename\n    def children(self):\n        return iter([(\"\", self.underlying)])",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdPriorityQueuePrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdPriorityQueuePrinter(object):\n    \"\"\"Print a std::priority_queue.\"\"\"\n    def __init__(self, val):\n        self.val = val\n        self.underlying = val[\"c\"]\n    def to_string(self):\n        # TODO(tamur): It would be nice to print the top element. The technical\n        # difficulty is that, the implementation refers to the underlying\n        # container, which is a generic class. libstdcxx pretty printers do not\n        # print the top element.",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "RBTreeUtils",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class RBTreeUtils(object):\n    \"\"\"Utility class for std::(multi)map, and std::(multi)set and iterators.\"\"\"\n    def __init__(self, cast_type, root):\n        self.cast_type = cast_type\n        self.root = root\n    def left_child(self, node):\n        result = node.cast(self.cast_type).dereference()[\"__left_\"]\n        return result\n    def right_child(self, node):\n        result = node.cast(self.cast_type).dereference()[\"__right_\"]",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "AbstractRBTreePrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class AbstractRBTreePrinter(object):\n    \"\"\"Abstract super class for std::(multi)map, and std::(multi)set.\"\"\"\n    def __init__(self, val):\n        self.val = val\n        tree = self.val[\"__tree_\"]\n        self.size = int(_value_of_pair_first(tree[\"__pair3_\"]))\n        dummy_root = tree[\"__pair1_\"]\n        root = _value_of_pair_first(dummy_root)[\"__left_\"]\n        cast_type = self._init_cast_type(val.type)\n        self.util = RBTreeUtils(cast_type, root)",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdMapPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdMapPrinter(AbstractRBTreePrinter):\n    \"\"\"Print a std::map or std::multimap.\"\"\"\n    def _init_cast_type(self, val_type):\n        map_it_type = gdb.lookup_type(\n            str(val_type.strip_typedefs()) + \"::iterator\").strip_typedefs()\n        tree_it_type = map_it_type.template_argument(0)\n        node_ptr_type = tree_it_type.template_argument(1)\n        return node_ptr_type\n    def display_hint(self):\n        return \"map\"",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdSetPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdSetPrinter(AbstractRBTreePrinter):\n    \"\"\"Print a std::set.\"\"\"\n    def _init_cast_type(self, val_type):\n        set_it_type = gdb.lookup_type(\n            str(val_type.strip_typedefs()) + \"::iterator\").strip_typedefs()\n        node_ptr_type = set_it_type.template_argument(1)\n        return node_ptr_type\n    def display_hint(self):\n        return \"array\"\n    def _get_key_value(self, node):",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "AbstractRBTreeIteratorPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class AbstractRBTreeIteratorPrinter(object):\n    \"\"\"Abstract super class for std::(multi)map, and std::(multi)set iterator.\"\"\"\n    def _initialize(self, val, typename):\n        self.typename = typename\n        self.val = val\n        self.addr = self.val[\"__ptr_\"]\n        cast_type = self.val.type.template_argument(1)\n        self.util = RBTreeUtils(cast_type, None)\n        if self.addr:\n            self.node = self.addr.cast(cast_type).dereference()",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "MapIteratorPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class MapIteratorPrinter(AbstractRBTreeIteratorPrinter):\n    \"\"\"Print a std::(multi)map iterator.\"\"\"\n    def __init__(self, val):\n        self._initialize(val[\"__i_\"],\n                         _remove_generics(_prettify_typename(val.type)))\n    def _get_node_value(self, node):\n        return node[\"__value_\"][\"__cc\"]\nclass SetIteratorPrinter(AbstractRBTreeIteratorPrinter):\n    \"\"\"Print a std::(multi)set iterator.\"\"\"\n    def __init__(self, val):",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "SetIteratorPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class SetIteratorPrinter(AbstractRBTreeIteratorPrinter):\n    \"\"\"Print a std::(multi)set iterator.\"\"\"\n    def __init__(self, val):\n        self._initialize(val, _remove_generics(_prettify_typename(val.type)))\n    def _get_node_value(self, node):\n        return node[\"__value_\"]\nclass StdFposPrinter(object):\n    \"\"\"Print a std::fpos or std::streampos.\"\"\"\n    def __init__(self, val):\n        self.val = val",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdFposPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdFposPrinter(object):\n    \"\"\"Print a std::fpos or std::streampos.\"\"\"\n    def __init__(self, val):\n        self.val = val\n    def to_string(self):\n        typename = _remove_generics(_prettify_typename(self.val.type))\n        offset = self.val[\"__off_\"]\n        state = self.val[\"__st_\"]\n        count = state[\"__count\"]\n        value = state[\"__value\"][\"__wch\"]",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "AbstractUnorderedCollectionPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class AbstractUnorderedCollectionPrinter(object):\n    \"\"\"Abstract super class for std::unordered_(multi)[set|map].\"\"\"\n    def __init__(self, val):\n        self.val = val\n        self.table = val[\"__table_\"]\n        self.sentinel = self.table[\"__p1_\"]\n        self.size = int(_value_of_pair_first(self.table[\"__p2_\"]))\n        node_base_type = self.sentinel.type.template_argument(0)\n        self.cast_type = node_base_type.template_argument(0)\n    def _list_it(self, sentinel_ptr):",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdUnorderedSetPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdUnorderedSetPrinter(AbstractUnorderedCollectionPrinter):\n    \"\"\"Print a std::unordered_(multi)set.\"\"\"\n    def _get_key_value(self, node):\n        return [node[\"__value_\"]]\n    def display_hint(self):\n        return \"array\"\nclass StdUnorderedMapPrinter(AbstractUnorderedCollectionPrinter):\n    \"\"\"Print a std::unordered_(multi)map.\"\"\"\n    def _get_key_value(self, node):\n        key_value = node[\"__value_\"][\"__cc\"]",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdUnorderedMapPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdUnorderedMapPrinter(AbstractUnorderedCollectionPrinter):\n    \"\"\"Print a std::unordered_(multi)map.\"\"\"\n    def _get_key_value(self, node):\n        key_value = node[\"__value_\"][\"__cc\"]\n        return [key_value[\"first\"], key_value[\"second\"]]\n    def display_hint(self):\n        return \"map\"\nclass AbstractHashMapIteratorPrinter(object):\n    \"\"\"Abstract class for unordered collection iterators.\"\"\"\n    def _initialize(self, val, addr):",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "AbstractHashMapIteratorPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class AbstractHashMapIteratorPrinter(object):\n    \"\"\"Abstract class for unordered collection iterators.\"\"\"\n    def _initialize(self, val, addr):\n        self.val = val\n        self.typename = _remove_generics(_prettify_typename(self.val.type))\n        self.addr = addr\n        if self.addr:\n            self.node = self.addr.cast(self.cast_type).dereference()\n    def _get_key_value(self):\n        \"\"\"Subclasses should override to return a list of values to yield.\"\"\"",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdUnorderedSetIteratorPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdUnorderedSetIteratorPrinter(AbstractHashMapIteratorPrinter):\n    \"\"\"Print a std::(multi)set iterator.\"\"\"\n    def __init__(self, val):\n        self.cast_type = val.type.template_argument(0)\n        self._initialize(val, val[\"__node_\"])\n    def _get_key_value(self):\n        return [self.node[\"__value_\"]]\n    def display_hint(self):\n        return \"array\"\nclass StdUnorderedMapIteratorPrinter(AbstractHashMapIteratorPrinter):",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "StdUnorderedMapIteratorPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class StdUnorderedMapIteratorPrinter(AbstractHashMapIteratorPrinter):\n    \"\"\"Print a std::(multi)map iterator.\"\"\"\n    def __init__(self, val):\n        self.cast_type = val.type.template_argument(0).template_argument(0)\n        self._initialize(val, val[\"__i_\"][\"__node_\"])\n    def _get_key_value(self):\n        key_value = self.node[\"__value_\"][\"__cc\"]\n        return [key_value[\"first\"], key_value[\"second\"]]\n    def display_hint(self):\n        return \"map\"",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "LibcxxPrettyPrinter",
        "kind": 6,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "class LibcxxPrettyPrinter(object):\n    \"\"\"PrettyPrinter object so gdb-commands like 'info pretty-printers' work.\"\"\"\n    def __init__(self, name):\n        super(LibcxxPrettyPrinter, self).__init__()\n        self.name = name\n        self.enabled = True\n        self.lookup = {\n            \"basic_string\": StdStringPrinter,\n            \"string\": StdStringPrinter,\n            \"string_view\": StdStringViewPrinter,",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "addr_as_long",
        "kind": 2,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "def addr_as_long(addr):\n    return int(addr.cast(_long_int_type))\n# The size of a pointer in bytes.\n_pointer_size = _void_pointer_type.sizeof\ndef _remove_cxx_namespace(typename):\n    \"\"\"Removed libc++ specific namespace from the type.\n    Arguments:\n      typename(string): A type, such as std::__u::something.\n    Returns:\n      A string without the libc++ specific part, such as std::something.",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "register_libcxx_printer_loader",
        "kind": 2,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "def register_libcxx_printer_loader():\n    \"\"\"Register event handlers to load libc++ pretty-printers.\"\"\"\n    gdb.events.new_objfile.connect(_register_libcxx_printers)\n    gdb.events.clear_objfiles.connect(_unregister_libcxx_printers)",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "_void_pointer_type",
        "kind": 5,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "_void_pointer_type = gdb.lookup_type(\"void\").pointer()\n_long_int_type = gdb.lookup_type(\"unsigned long long\")\n_libcpp_big_endian = False\ndef addr_as_long(addr):\n    return int(addr.cast(_long_int_type))\n# The size of a pointer in bytes.\n_pointer_size = _void_pointer_type.sizeof\ndef _remove_cxx_namespace(typename):\n    \"\"\"Removed libc++ specific namespace from the type.\n    Arguments:",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "_long_int_type",
        "kind": 5,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "_long_int_type = gdb.lookup_type(\"unsigned long long\")\n_libcpp_big_endian = False\ndef addr_as_long(addr):\n    return int(addr.cast(_long_int_type))\n# The size of a pointer in bytes.\n_pointer_size = _void_pointer_type.sizeof\ndef _remove_cxx_namespace(typename):\n    \"\"\"Removed libc++ specific namespace from the type.\n    Arguments:\n      typename(string): A type, such as std::__u::something.",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "_libcpp_big_endian",
        "kind": 5,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "_libcpp_big_endian = False\ndef addr_as_long(addr):\n    return int(addr.cast(_long_int_type))\n# The size of a pointer in bytes.\n_pointer_size = _void_pointer_type.sizeof\ndef _remove_cxx_namespace(typename):\n    \"\"\"Removed libc++ specific namespace from the type.\n    Arguments:\n      typename(string): A type, such as std::__u::something.\n    Returns:",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "_pointer_size",
        "kind": 5,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "_pointer_size = _void_pointer_type.sizeof\ndef _remove_cxx_namespace(typename):\n    \"\"\"Removed libc++ specific namespace from the type.\n    Arguments:\n      typename(string): A type, such as std::__u::something.\n    Returns:\n      A string without the libc++ specific part, such as std::something.\n    \"\"\"\n    return re.sub(\"std::__.*?::\", \"std::\", typename)\ndef _remove_generics(typename):",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "_common_substitutions",
        "kind": 5,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "_common_substitutions = [\n    (\"std::basic_string<char, std::char_traits<char>, std::allocator<char> >\",\n     \"std::string\"),\n    (\"std::basic_string_view<char, std::char_traits<char> >\",\n     \"std::string_view\"),\n]\ndef _prettify_typename(gdb_type):\n    \"\"\"Returns a pretty name for the type, or None if no name can be found.\n    Arguments:\n      gdb_type(gdb.Type): A type object.",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "_libcxx_printer_name",
        "kind": 5,
        "importPath": "src.libcxx.utils.gdb.libcxx.printers",
        "description": "src.libcxx.utils.gdb.libcxx.printers",
        "peekOfCode": "_libcxx_printer_name = \"libcxx_pretty_printer\"\n# These are called for every binary object file, which could be thousands in\n# certain pathological cases. Limit our pretty printers to the progspace.\ndef _register_libcxx_printers(event):\n    progspace = event.new_objfile.progspace\n    # It would be ideal to get the endianness at print time, but\n    # gdb.execute clears gdb's internal wrap buffer, removing any values\n    # already generated as part of a larger data structure, and there is\n    # no python _api to get the endianness. Mixed-endianness debugging\n    # rare enough that this workaround should be adequate.",
        "detail": "src.libcxx.utils.gdb.libcxx.printers",
        "documentation": {}
    },
    {
        "label": "added_symbols",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.diff",
        "description": "src.libcxx.utils.libcxx.sym_check.diff",
        "peekOfCode": "def added_symbols(old, new):\n    return _symbol_difference(new, old)\ndef removed_symbols(old, new):\n    return _symbol_difference(old, new)\ndef changed_symbols(old, new):\n    changed = []\n    for old_sym in old:\n        if old_sym in new:\n            continue\n        new_sym = _find_by_key(new, old_sym['name'])",
        "detail": "src.libcxx.utils.libcxx.sym_check.diff",
        "documentation": {}
    },
    {
        "label": "removed_symbols",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.diff",
        "description": "src.libcxx.utils.libcxx.sym_check.diff",
        "peekOfCode": "def removed_symbols(old, new):\n    return _symbol_difference(old, new)\ndef changed_symbols(old, new):\n    changed = []\n    for old_sym in old:\n        if old_sym in new:\n            continue\n        new_sym = _find_by_key(new, old_sym['name'])\n        if (new_sym is not None and not new_sym in old\n                and old_sym != new_sym):",
        "detail": "src.libcxx.utils.libcxx.sym_check.diff",
        "documentation": {}
    },
    {
        "label": "changed_symbols",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.diff",
        "description": "src.libcxx.utils.libcxx.sym_check.diff",
        "peekOfCode": "def changed_symbols(old, new):\n    changed = []\n    for old_sym in old:\n        if old_sym in new:\n            continue\n        new_sym = _find_by_key(new, old_sym['name'])\n        if (new_sym is not None and not new_sym in old\n                and old_sym != new_sym):\n            changed += [(old_sym, new_sym)]\n    return changed",
        "detail": "src.libcxx.utils.libcxx.sym_check.diff",
        "documentation": {}
    },
    {
        "label": "diff",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.diff",
        "description": "src.libcxx.utils.libcxx.sym_check.diff",
        "peekOfCode": "def diff(old, new):\n    added = added_symbols(old, new)\n    removed = removed_symbols(old, new)\n    changed = changed_symbols(old, new)\n    return added, removed, changed\ndef report_diff(added_syms, removed_syms, changed_syms, names_only=False,\n                demangle=True):\n    def maybe_demangle(name):\n        return util.demangle_symbol(name) if demangle else name\n    report = ''",
        "detail": "src.libcxx.utils.libcxx.sym_check.diff",
        "documentation": {}
    },
    {
        "label": "report_diff",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.diff",
        "description": "src.libcxx.utils.libcxx.sym_check.diff",
        "peekOfCode": "def report_diff(added_syms, removed_syms, changed_syms, names_only=False,\n                demangle=True):\n    def maybe_demangle(name):\n        return util.demangle_symbol(name) if demangle else name\n    report = ''\n    for sym in added_syms:\n        report += 'Symbol added: %s\\n' % maybe_demangle(sym['name'])\n        if not names_only:\n            report += '    %s\\n\\n' % sym\n    if added_syms and names_only:",
        "detail": "src.libcxx.utils.libcxx.sym_check.diff",
        "documentation": {}
    },
    {
        "label": "NMExtractor",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.sym_check.extract",
        "description": "src.libcxx.utils.libcxx.sym_check.extract",
        "peekOfCode": "class NMExtractor(object):\n    \"\"\"\n    NMExtractor - Extract symbol lists from libraries using nm.\n    \"\"\"\n    @staticmethod\n    def find_tool():\n        \"\"\"\n        Search for the nm executable and return the path.\n        \"\"\"\n        return distutils.spawn.find_executable('nm')",
        "detail": "src.libcxx.utils.libcxx.sym_check.extract",
        "documentation": {}
    },
    {
        "label": "ReadElfExtractor",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.sym_check.extract",
        "description": "src.libcxx.utils.libcxx.sym_check.extract",
        "peekOfCode": "class ReadElfExtractor(object):\n    \"\"\"\n    ReadElfExtractor - Extract symbol lists from libraries using readelf.\n    \"\"\"\n    @staticmethod\n    def find_tool():\n        \"\"\"\n        Search for the readelf executable and return the path.\n        \"\"\"\n        return distutils.spawn.find_executable('readelf')",
        "detail": "src.libcxx.utils.libcxx.sym_check.extract",
        "documentation": {}
    },
    {
        "label": "AIXDumpExtractor",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.sym_check.extract",
        "description": "src.libcxx.utils.libcxx.sym_check.extract",
        "peekOfCode": "class AIXDumpExtractor(object):\n     \"\"\"\n     AIXDumpExtractor - Extract symbol lists from libraries using AIX dump.\n     \"\"\"\n     @staticmethod\n     def find_tool():\n         \"\"\"\n         Search for the dump executable and return the path.\n         \"\"\"\n         return distutils.spawn.find_executable('dump')",
        "detail": "src.libcxx.utils.libcxx.sym_check.extract",
        "documentation": {}
    },
    {
        "label": "is_static_library",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.extract",
        "description": "src.libcxx.utils.libcxx.sym_check.extract",
        "peekOfCode": "def is_static_library(lib_file):\n     \"\"\"\n     Determine if a given library is static or shared.\n     \"\"\"\n     if sys.platform.startswith('aix'):\n         # An AIX library could be both, but for simplicity assume it isn't.\n         return not AIXDumpExtractor.is_shared_lib(lib_file)\n     else:\n         _, ext = os.path.splitext(lib_file)\n         return ext == '.a'",
        "detail": "src.libcxx.utils.libcxx.sym_check.extract",
        "documentation": {}
    },
    {
        "label": "extract_symbols",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.extract",
        "description": "src.libcxx.utils.libcxx.sym_check.extract",
        "peekOfCode": "def extract_symbols(lib_file, static_lib=None):\n    \"\"\"\n    Extract and return a list of symbols extracted from a static or dynamic\n    library. The symbols are extracted using dump, nm or readelf. They are\n    then filtered and formated. Finally the symbols are made unique.\n    \"\"\"\n    if static_lib is None:\n        static_lib = is_static_library(lib_file)\n    if sys.platform.startswith('aix'):\n        extractor = AIXDumpExtractor(static_lib=static_lib)",
        "detail": "src.libcxx.utils.libcxx.sym_check.extract",
        "documentation": {}
    },
    {
        "label": "extract_ignore_names",
        "kind": 5,
        "importPath": "src.libcxx.utils.libcxx.sym_check.extract",
        "description": "src.libcxx.utils.libcxx.sym_check.extract",
        "peekOfCode": "extract_ignore_names = ['_init', '_fini']\nclass NMExtractor(object):\n    \"\"\"\n    NMExtractor - Extract symbol lists from libraries using nm.\n    \"\"\"\n    @staticmethod\n    def find_tool():\n        \"\"\"\n        Search for the nm executable and return the path.\n        \"\"\"",
        "detail": "src.libcxx.utils.libcxx.sym_check.extract",
        "documentation": {}
    },
    {
        "label": "find_and_report_matching",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.match",
        "description": "src.libcxx.utils.libcxx.sym_check.match",
        "peekOfCode": "def find_and_report_matching(symbol_list, regex_list):\n    report = ''\n    found_count = 0\n    for regex_str in regex_list:\n        report += 'Matching regex \"%s\":\\n' % regex_str\n        matching_list = find_matching_symbols(symbol_list, regex_str)\n        if not matching_list:\n            report += '    No matches found\\n\\n'\n            continue\n        # else",
        "detail": "src.libcxx.utils.libcxx.sym_check.match",
        "documentation": {}
    },
    {
        "label": "find_matching_symbols",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.match",
        "description": "src.libcxx.utils.libcxx.sym_check.match",
        "peekOfCode": "def find_matching_symbols(symbol_list, regex_str):\n    regex = re.compile(regex_str)\n    matching_list = []\n    for s in symbol_list:\n        if regex.match(s['name']):\n            matching_list += [s]\n    return matching_list",
        "detail": "src.libcxx.utils.libcxx.sym_check.match",
        "documentation": {}
    },
    {
        "label": "read_syms_from_list",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "def read_syms_from_list(slist):\n    \"\"\"\n    Read a list of symbols from a list of strings.\n    Each string is one symbol.\n    \"\"\"\n    return [ast.literal_eval(l) for l in slist]\ndef read_syms_from_file(filename):\n    \"\"\"\n    Read a list of symbols in from a file.\n    \"\"\"",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "read_syms_from_file",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "def read_syms_from_file(filename):\n    \"\"\"\n    Read a list of symbols in from a file.\n    \"\"\"\n    with open(filename, 'r') as f:\n        data = f.read()\n    return read_syms_from_list(data.splitlines())\ndef read_exclusions(filename):\n    with open(filename, 'r') as f:\n        data = f.read()",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "read_exclusions",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "def read_exclusions(filename):\n    with open(filename, 'r') as f:\n        data = f.read()\n    lines = [l.strip() for l in data.splitlines() if l.strip()]\n    lines = [l for l in lines if not l.startswith('#')]\n    return lines\ndef write_syms(sym_list, out=None, names_only=False, filter=None):\n    \"\"\"\n    Write a list of symbols to the file named by out.\n    \"\"\"",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "write_syms",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "def write_syms(sym_list, out=None, names_only=False, filter=None):\n    \"\"\"\n    Write a list of symbols to the file named by out.\n    \"\"\"\n    out_str = ''\n    out_list = sym_list\n    out_list.sort(key=lambda x: x['name'])\n    if filter is not None:\n        out_list = filter(out_list)\n    if names_only:",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "demangle_symbol",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "def demangle_symbol(symbol):\n    if _cppfilt_exe is None:\n        return symbol\n    result = subprocess.run([_cppfilt_exe], input=symbol.encode(), capture_output=True)\n    if result.returncode != 0:\n        return symbol\n    return result.stdout.decode()\ndef is_elf(filename):\n    with open(filename, 'rb') as f:\n        magic_bytes = f.read(4)",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "is_elf",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "def is_elf(filename):\n    with open(filename, 'rb') as f:\n        magic_bytes = f.read(4)\n    return magic_bytes == b'\\x7fELF'\ndef is_mach_o(filename):\n    with open(filename, 'rb') as f:\n        magic_bytes = f.read(4)\n    return magic_bytes in [\n        b'\\xfe\\xed\\xfa\\xce',  # MH_MAGIC\n        b'\\xce\\xfa\\xed\\xfe',  # MH_CIGAM",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "is_mach_o",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "def is_mach_o(filename):\n    with open(filename, 'rb') as f:\n        magic_bytes = f.read(4)\n    return magic_bytes in [\n        b'\\xfe\\xed\\xfa\\xce',  # MH_MAGIC\n        b'\\xce\\xfa\\xed\\xfe',  # MH_CIGAM\n        b'\\xfe\\xed\\xfa\\xcf',  # MH_MAGIC_64\n        b'\\xcf\\xfa\\xed\\xfe',  # MH_CIGAM_64\n        b'\\xca\\xfe\\xba\\xbe',  # FAT_MAGIC\n        b'\\xbe\\xba\\xfe\\xca'   # FAT_CIGAM",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "is_xcoff_or_big_ar",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "def is_xcoff_or_big_ar(filename):\n    with open(filename, 'rb') as f:\n        magic_bytes = f.read(7)\n    return magic_bytes[:4] in [\n        b'\\x01DF',  # XCOFF32\n        b'\\x01F7'   # XCOFF64\n    ] or magic_bytes == b'<bigaf>'\ndef is_library_file(filename):\n    if sys.platform == 'darwin':\n        return is_mach_o(filename)",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "is_library_file",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "def is_library_file(filename):\n    if sys.platform == 'darwin':\n        return is_mach_o(filename)\n    elif sys.platform.startswith('aix'):\n        return is_xcoff_or_big_ar(filename)\n    else:\n        return is_elf(filename)\ndef extract_or_load(filename):\n    import libcxx.sym_check.extract\n    if is_library_file(filename):",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "extract_or_load",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "def extract_or_load(filename):\n    import libcxx.sym_check.extract\n    if is_library_file(filename):\n        return libcxx.sym_check.extract.extract_symbols(filename)\n    return read_syms_from_file(filename)\ndef adjust_mangled_name(name):\n    if not name.startswith('__Z'):\n        return name\n    return name[1:]\nnew_delete_std_symbols = [",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "adjust_mangled_name",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "def adjust_mangled_name(name):\n    if not name.startswith('__Z'):\n        return name\n    return name[1:]\nnew_delete_std_symbols = [\n    '_Znam',\n    '_Znwm',\n    '_ZdaPv',\n    '_ZdaPvm',\n    '_ZdlPv',",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "is_stdlib_symbol_name",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "def is_stdlib_symbol_name(name, sym):\n    name = adjust_mangled_name(name)\n    if re.search(\"@GLIBC|@GCC\", name):\n        # Only when symbol is defined do we consider it ours\n        return sym['is_defined']\n    if re.search('(St[0-9])|(__cxa)|(__cxxabi)', name):\n        return True\n    if name in new_delete_std_symbols:\n        return True\n    if name in cxxabi_symbols:",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "filter_stdlib_symbols",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "def filter_stdlib_symbols(syms):\n    stdlib_symbols = []\n    other_symbols = []\n    for s in syms:\n        canon_name = adjust_mangled_name(s['name'])\n        if not is_stdlib_symbol_name(canon_name, s):\n            other_symbols += [s]\n        else:\n            stdlib_symbols += [s]\n    return stdlib_symbols, other_symbols",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "_cppfilt_exe",
        "kind": 5,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "_cppfilt_exe = distutils.spawn.find_executable('c++filt')\ndef demangle_symbol(symbol):\n    if _cppfilt_exe is None:\n        return symbol\n    result = subprocess.run([_cppfilt_exe], input=symbol.encode(), capture_output=True)\n    if result.returncode != 0:\n        return symbol\n    return result.stdout.decode()\ndef is_elf(filename):\n    with open(filename, 'rb') as f:",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "new_delete_std_symbols",
        "kind": 5,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "new_delete_std_symbols = [\n    '_Znam',\n    '_Znwm',\n    '_ZdaPv',\n    '_ZdaPvm',\n    '_ZdlPv',\n    '_ZdlPvm'\n]\ncxxabi_symbols = [\n    '___dynamic_cast',",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "cxxabi_symbols",
        "kind": 5,
        "importPath": "src.libcxx.utils.libcxx.sym_check.util",
        "description": "src.libcxx.utils.libcxx.sym_check.util",
        "peekOfCode": "cxxabi_symbols = [\n    '___dynamic_cast',\n    '___gxx_personality_v0',\n    '_ZTIDi',\n    '_ZTIDn',\n    '_ZTIDs',\n    '_ZTIPDi',\n    '_ZTIPDn',\n    '_ZTIPDs',\n    '_ZTIPKDi',",
        "detail": "src.libcxx.utils.libcxx.sym_check.util",
        "documentation": {}
    },
    {
        "label": "Configuration",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.config",
        "description": "src.libcxx.utils.libcxx.test.config",
        "peekOfCode": "class Configuration(object):\n    # pylint: disable=redefined-outer-name\n    def __init__(self, lit_config, config):\n        self.lit_config = lit_config\n        self.config = config\n        self.cxx = None\n        self.cxx_is_clang_cl = None\n        self.cxx_stdlib_under_test = None\n        self.project_obj_root = None\n        self.libcxx_src_root = None",
        "detail": "src.libcxx.utils.libcxx.test.config",
        "documentation": {}
    },
    {
        "label": "loadSiteConfig",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.config",
        "description": "src.libcxx.utils.libcxx.test.config",
        "peekOfCode": "def loadSiteConfig(lit_config, config, param_name, env_name):\n    # We haven't loaded the site specific configuration (the user is\n    # probably trying to run on a test file directly, and either the site\n    # configuration hasn't been created by the build system, or we are in an\n    # out-of-tree build situation).\n    site_cfg = lit_config.params.get(param_name,\n                                     os.environ.get(env_name))\n    if not site_cfg:\n        lit_config.warning('No site specific configuration file found!'\n                           ' Running the tests in the default configuration.')",
        "detail": "src.libcxx.utils.libcxx.test.config",
        "documentation": {}
    },
    {
        "label": "intMacroValue",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.config",
        "description": "src.libcxx.utils.libcxx.test.config",
        "peekOfCode": "def intMacroValue(token):\n    return int(token.rstrip('LlUu'))\nclass Configuration(object):\n    # pylint: disable=redefined-outer-name\n    def __init__(self, lit_config, config):\n        self.lit_config = lit_config\n        self.config = config\n        self.cxx = None\n        self.cxx_is_clang_cl = None\n        self.cxx_stdlib_under_test = None",
        "detail": "src.libcxx.utils.libcxx.test.config",
        "documentation": {}
    },
    {
        "label": "ConfigurationError",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "class ConfigurationError(Exception):\n  pass\nclass ConfigurationCompilationError(ConfigurationError):\n  pass\nclass ConfigurationRuntimeError(ConfigurationError):\n  pass\ndef _memoizeExpensiveOperation(extractCacheKey):\n  \"\"\"\n  Allows memoizing a very expensive operation.\n  We pickle the cache key to make sure we store an immutable representation",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "ConfigurationCompilationError",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "class ConfigurationCompilationError(ConfigurationError):\n  pass\nclass ConfigurationRuntimeError(ConfigurationError):\n  pass\ndef _memoizeExpensiveOperation(extractCacheKey):\n  \"\"\"\n  Allows memoizing a very expensive operation.\n  We pickle the cache key to make sure we store an immutable representation\n  of it. If we stored an object and the object was referenced elsewhere, it\n  could be changed from under our feet, which would break the cache.",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "ConfigurationRuntimeError",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "class ConfigurationRuntimeError(ConfigurationError):\n  pass\ndef _memoizeExpensiveOperation(extractCacheKey):\n  \"\"\"\n  Allows memoizing a very expensive operation.\n  We pickle the cache key to make sure we store an immutable representation\n  of it. If we stored an object and the object was referenced elsewhere, it\n  could be changed from under our feet, which would break the cache.\n  We also store the cache for a given function persistently across invocations\n  of Lit. This dramatically speeds up the configuration of the test suite when",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "ConfigAction",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "class ConfigAction(object):\n  \"\"\"\n  This class represents an action that can be performed on a Lit TestingConfig\n  object.\n  Examples of such actions are adding or modifying substitutions, Lit features,\n  etc. This class only provides the interface of such actions, and it is meant\n  to be subclassed appropriately to create new actions.\n  \"\"\"\n  def applyTo(self, config):\n    \"\"\"",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "AddFeature",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "class AddFeature(ConfigAction):\n  \"\"\"\n  This action defines the given Lit feature when running the test suite.\n  The name of the feature can be a string or a callable, in which case it is\n  called with the configuration to produce the feature name (as a string).\n  \"\"\"\n  def __init__(self, name):\n    self._name = name\n  def _getName(self, config):\n    name = self._name(config) if callable(self._name) else self._name",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "AddFlag",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "class AddFlag(ConfigAction):\n  \"\"\"\n  This action adds the given flag to the %{flags} substitution.\n  The flag can be a string or a callable, in which case it is called with the\n  configuration to produce the actual flag (as a string).\n  \"\"\"\n  def __init__(self, flag):\n    self._getFlag = lambda config: flag(config) if callable(flag) else flag\n  def applyTo(self, config):\n    flag = self._getFlag(config)",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "AddFlagIfSupported",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "class AddFlagIfSupported(ConfigAction):\n  \"\"\"\n  This action adds the given flag to the %{flags} substitution, only if\n  the compiler supports the flag.\n  The flag can be a string or a callable, in which case it is called with the\n  configuration to produce the actual flag (as a string).\n  \"\"\"\n  def __init__(self, flag):\n    self._getFlag = lambda config: flag(config) if callable(flag) else flag\n  def applyTo(self, config):",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "AddCompileFlag",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "class AddCompileFlag(ConfigAction):\n  \"\"\"\n  This action adds the given flag to the %{compile_flags} substitution.\n  The flag can be a string or a callable, in which case it is called with the\n  configuration to produce the actual flag (as a string).\n  \"\"\"\n  def __init__(self, flag):\n    self._getFlag = lambda config: flag(config) if callable(flag) else flag\n  def applyTo(self, config):\n    flag = self._getFlag(config)",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "AddLinkFlag",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "class AddLinkFlag(ConfigAction):\n  \"\"\"\n  This action appends the given flag to the %{link_flags} substitution.\n  The flag can be a string or a callable, in which case it is called with the\n  configuration to produce the actual flag (as a string).\n  \"\"\"\n  def __init__(self, flag):\n    self._getFlag = lambda config: flag(config) if callable(flag) else flag\n  def applyTo(self, config):\n    flag = self._getFlag(config)",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "PrependLinkFlag",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "class PrependLinkFlag(ConfigAction):\n  \"\"\"\n  This action prepends the given flag to the %{link_flags} substitution.\n  The flag can be a string or a callable, in which case it is called with the\n  configuration to produce the actual flag (as a string).\n  \"\"\"\n  def __init__(self, flag):\n    self._getFlag = lambda config: flag(config) if callable(flag) else flag\n  def applyTo(self, config):\n    flag = self._getFlag(config)",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "AddOptionalWarningFlag",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "class AddOptionalWarningFlag(ConfigAction):\n  \"\"\"\n  This action adds the given warning flag to the %{compile_flags} substitution,\n  if it is supported by the compiler.\n  The flag can be a string or a callable, in which case it is called with the\n  configuration to produce the actual flag (as a string).\n  \"\"\"\n  def __init__(self, flag):\n    self._getFlag = lambda config: flag(config) if callable(flag) else flag\n  def applyTo(self, config):",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "AddSubstitution",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "class AddSubstitution(ConfigAction):\n  \"\"\"\n  This action adds the given substitution to the Lit configuration.\n  The substitution can be a string or a callable, in which case it is called\n  with the configuration to produce the actual substitution (as a string).\n  \"\"\"\n  def __init__(self, key, substitution):\n    self._key = key\n    self._getSub = lambda config: substitution(config) if callable(substitution) else substitution\n  def applyTo(self, config):",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "Feature",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "class Feature(object):\n  \"\"\"\n  Represents a Lit available feature that is enabled whenever it is supported.\n  A feature like this informs the test suite about a capability of the compiler,\n  platform, etc. Unlike Parameters, it does not make sense to explicitly\n  control whether a Feature is enabled -- it should be enabled whenever it\n  is supported.\n  \"\"\"\n  def __init__(self, name, actions=None, when=lambda _: True):\n    \"\"\"",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "Parameter",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "class Parameter(object):\n  \"\"\"\n  Represents a parameter of a Lit test suite.\n  Parameters are used to customize the behavior of test suites in a user\n  controllable way. There are two ways of setting the value of a Parameter.\n  The first one is to pass `--param <KEY>=<VALUE>` when running Lit (or\n  equivalenlty to set `litConfig.params[KEY] = VALUE` somewhere in the\n  Lit configuration files. This method will set the parameter globally for\n  all test suites being run.\n  The second method is to set `config.KEY = VALUE` somewhere in the Lit",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "sourceBuilds",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "def sourceBuilds(config, source, additionalFlags=[]):\n  \"\"\"\n  Return whether the program in the given string builds successfully.\n  This is done by compiling and linking a program that consists of the given\n  source with the %{cxx} substitution, and seeing whether that succeeds. If\n  any additional flags are passed, they are appended to the compiler invocation.\n  \"\"\"\n  with _makeConfigTest(config) as test:\n    with open(test.getSourcePath(), 'w') as sourceFile:\n      sourceFile.write(source)",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "programOutput",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "def programOutput(config, program, args=None):\n  \"\"\"\n  Compiles a program for the test target, run it on the test target and return\n  the output.\n  Note that execution of the program is done through the %{exec} substitution,\n  which means that the program may be run on a remote host depending on what\n  %{exec} does.\n  \"\"\"\n  if args is None:\n    args = []",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "programSucceeds",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "def programSucceeds(config, program, args=None):\n  \"\"\"\n  Compiles a program for the test target, run it on the test target and return\n  whether it completed successfully.\n  Note that execution of the program is done through the %{exec} substitution,\n  which means that the program may be run on a remote host depending on what\n  %{exec} does.\n  \"\"\"\n  try:\n    programOutput(config, program, args)",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "hasCompileFlag",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "def hasCompileFlag(config, flag):\n  \"\"\"\n  Return whether the compiler in the configuration supports a given compiler flag.\n  This is done by executing the %{cxx} substitution with the given flag and\n  checking whether that succeeds.\n  \"\"\"\n  with _makeConfigTest(config) as test:\n    out, err, exitCode, timeoutInfo = _executeScriptInternal(test, [\n      \"%{{cxx}} -xc++ {} -Werror -fsyntax-only %{{flags}} %{{compile_flags}} {}\".format(os.devnull, flag)\n    ])",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "runScriptExitCode",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "def runScriptExitCode(config, script):\n  \"\"\"\n  Runs the given script as a Lit test, and returns the exit code of the execution.\n  The script must be a list of commands, each of which being something that\n  could appear on the right-hand-side of a `RUN:` keyword.\n  \"\"\"\n  with _makeConfigTest(config) as test:\n    _, _, exitCode, _ = _executeScriptInternal(test, script)\n    return exitCode\n@_memoizeExpensiveOperation(lambda c, s: (c.substitutions, c.environment, s))",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "commandOutput",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "def commandOutput(config, command):\n  \"\"\"\n  Runs the given script as a Lit test, and returns the output.\n  If the exit code isn't 0 an exception is raised.\n  The script must be a list of commands, each of which being something that\n  could appear on the right-hand-side of a `RUN:` keyword.\n  \"\"\"\n  with _makeConfigTest(config) as test:\n    out, _, exitCode, _ = _executeScriptInternal(test, command)\n    if exitCode != 0:",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "hasAnyLocale",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "def hasAnyLocale(config, locales):\n  \"\"\"\n  Return whether the runtime execution environment supports a given locale.\n  Different systems may use different names for a locale, so this function checks\n  whether any of the passed locale names is supported by setlocale() and returns\n  true if one of them works.\n  This is done by executing a program that tries to set the given locale using\n  %{exec} -- this means that the command may be executed on a remote host\n  depending on the %{exec} substitution.\n  \"\"\"",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "compilerMacros",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "def compilerMacros(config, flags=''):\n  \"\"\"\n  Return a dictionary of predefined compiler macros.\n  The keys are strings representing macros, and the values are strings\n  representing what each macro is defined to.\n  If the optional `flags` argument (a string) is provided, these flags will\n  be added to the compiler invocation when generating the macros.\n  \"\"\"\n  with _makeConfigTest(config) as test:\n    with open(test.getSourcePath(), 'w') as sourceFile:",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "featureTestMacros",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.dsl",
        "description": "src.libcxx.utils.libcxx.test.dsl",
        "peekOfCode": "def featureTestMacros(config, flags=''):\n  \"\"\"\n  Return a dictionary of feature test macros.\n  The keys are strings representing feature test macros, and the values are\n  integers representing the value of the macro.\n  \"\"\"\n  allMacros = compilerMacros(config, flags)\n  return {m: int(v.rstrip('LlUu')) for (m, v) in allMacros.items() if m.startswith('__cpp_')}\ndef _appendToSubstitution(substitutions, key, value):\n  return [(k, v + ' ' + value) if k == key else (k, v) for (k, v) in substitutions]",
        "detail": "src.libcxx.utils.libcxx.test.dsl",
        "documentation": {}
    },
    {
        "label": "check_gdb",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.features",
        "description": "src.libcxx.utils.libcxx.test.features",
        "peekOfCode": "def check_gdb(cfg):\n  gdb_path = shutil.which('gdb')\n  if gdb_path is None:\n    return False\n  # Check that we can set breakpoint commands, which was added in 8.3.\n  # Using the quit command here means that gdb itself exits, not just\n  # the \"python <...>\" command.\n  test_src = \"\"\"\\\ntry:\n  gdb.Breakpoint(\\\"main\\\").commands=\\\"foo\\\"",
        "detail": "src.libcxx.utils.libcxx.test.features",
        "documentation": {}
    },
    {
        "label": "_isAppleClang",
        "kind": 5,
        "importPath": "src.libcxx.utils.libcxx.test.features",
        "description": "src.libcxx.utils.libcxx.test.features",
        "peekOfCode": "_isAppleClang = lambda cfg: '__apple_build_version__' in compilerMacros(cfg)\n_isGCC        = lambda cfg: '__GNUC__' in compilerMacros(cfg) and '__clang__' not in compilerMacros(cfg)\n_isMSVC       = lambda cfg: '_MSC_VER' in compilerMacros(cfg)\n_msvcVersion  = lambda cfg: (int(compilerMacros(cfg)['_MSC_VER']) // 100, int(compilerMacros(cfg)['_MSC_VER']) % 100)\ndef _hasSuitableClangTidy(cfg):\n  try:\n    return int(re.search('[0-9]+', commandOutput(cfg, ['clang-tidy --version'])).group()) >= 13\n  except ConfigurationRuntimeError:\n    return False\nDEFAULT_FEATURES = [",
        "detail": "src.libcxx.utils.libcxx.test.features",
        "documentation": {}
    },
    {
        "label": "DEFAULT_FEATURES",
        "kind": 5,
        "importPath": "src.libcxx.utils.libcxx.test.features",
        "description": "src.libcxx.utils.libcxx.test.features",
        "peekOfCode": "DEFAULT_FEATURES = [\n  Feature(name='fcoroutines-ts',\n          when=lambda cfg: hasCompileFlag(cfg, '-fcoroutines-ts') and\n                           featureTestMacros(cfg, flags='-fcoroutines-ts').get('__cpp_coroutines', 0) >= 201703,\n          actions=[AddCompileFlag('-fcoroutines-ts')]),\n  Feature(name='thread-safety',\n          when=lambda cfg: hasCompileFlag(cfg, '-Werror=thread-safety'),\n          actions=[AddCompileFlag('-Werror=thread-safety')]),\n  Feature(name='diagnose-if-support',\n          when=lambda cfg: hasCompileFlag(cfg, '-Wuser-defined-warnings'),",
        "detail": "src.libcxx.utils.libcxx.test.features",
        "documentation": {}
    },
    {
        "label": "macros",
        "kind": 5,
        "importPath": "src.libcxx.utils.libcxx.test.features",
        "description": "src.libcxx.utils.libcxx.test.features",
        "peekOfCode": "macros = {\n  '_LIBCPP_HAS_NO_MONOTONIC_CLOCK': 'no-monotonic-clock',\n  '_LIBCPP_HAS_NO_THREADS': 'no-threads',\n  '_LIBCPP_HAS_THREAD_API_EXTERNAL': 'libcpp-has-thread-_api-external',\n  '_LIBCPP_HAS_THREAD_API_PTHREAD': 'libcpp-has-thread-_api-pthread',\n  '_LIBCPP_NO_VCRUNTIME': 'libcpp-no-vcruntime',\n  '_LIBCPP_ABI_VERSION': 'libcpp-abi-version',\n  '_LIBCPP_HAS_NO_FILESYSTEM_LIBRARY': 'no-filesystem',\n  '_LIBCPP_HAS_NO_RANDOM_DEVICE': 'no-random-device',\n  '_LIBCPP_HAS_NO_LOCALIZATION': 'no-localization',",
        "detail": "src.libcxx.utils.libcxx.test.features",
        "documentation": {}
    },
    {
        "label": "locales",
        "kind": 5,
        "importPath": "src.libcxx.utils.libcxx.test.features",
        "description": "src.libcxx.utils.libcxx.test.features",
        "peekOfCode": "locales = {\n  'en_US.UTF-8':     ['en_US.UTF-8', 'en_US.utf8', 'English_United States.1252'],\n  'fr_FR.UTF-8':     ['fr_FR.UTF-8', 'fr_FR.utf8', 'French_France.1252'],\n  'ja_JP.UTF-8':     ['ja_JP.UTF-8', 'ja_JP.utf8', 'Japanese_Japan.923'],\n  'ru_RU.UTF-8':     ['ru_RU.UTF-8', 'ru_RU.utf8', 'Russian_Russia.1251'],\n  'zh_CN.UTF-8':     ['zh_CN.UTF-8', 'zh_CN.utf8', 'Chinese_China.936'],\n  'fr_CA.ISO8859-1': ['fr_CA.ISO8859-1', 'French_Canada.1252'],\n  'cs_CZ.ISO8859-2': ['cs_CZ.ISO8859-2', 'Czech_Czech Republic.1250']\n}\nfor locale, alts in locales.items():",
        "detail": "src.libcxx.utils.libcxx.test.features",
        "documentation": {}
    },
    {
        "label": "CxxStandardLibraryTest",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.format",
        "description": "src.libcxx.utils.libcxx.test.format",
        "peekOfCode": "class CxxStandardLibraryTest(lit.formats.TestFormat):\n    \"\"\"\n    Lit test format for the C++ Standard Library conformance test suite.\n    This test format is based on top of the ShTest format -- it basically\n    creates a shell script performing the right operations (compile/link/run)\n    based on the extension of the test file it encounters. It supports files\n    with the following extensions:\n    FOO.pass.cpp            - Compiles, links and runs successfully\n    FOO.pass.mm             - Same as .pass.cpp, but for Objective-C++\n    FOO.compile.pass.cpp    - Compiles successfully, link and run not attempted",
        "detail": "src.libcxx.utils.libcxx.test.format",
        "documentation": {}
    },
    {
        "label": "parseScript",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.format",
        "description": "src.libcxx.utils.libcxx.test.format",
        "peekOfCode": "def parseScript(test, preamble):\n    \"\"\"\n    Extract the script from a test, with substitutions applied.\n    Returns a list of commands ready to be executed.\n    - test\n        The lit.Test to parse.\n    - preamble\n        A list of commands to perform before any command in the test.\n        These commands can contain unexpanded substitutions, but they\n        must not be of the form 'RUN:' -- they must be proper commands",
        "detail": "src.libcxx.utils.libcxx.test.format",
        "documentation": {}
    },
    {
        "label": "GoogleBenchmark",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.googlebenchmark",
        "description": "src.libcxx.utils.libcxx.test.googlebenchmark",
        "peekOfCode": "class GoogleBenchmark(TestFormat):\n    def __init__(self, test_sub_dirs, test_suffix, benchmark_args=[]):\n        self.benchmark_args = list(benchmark_args)\n        self.test_sub_dirs = os.path.normcase(str(test_sub_dirs)).split(';')\n        # On Windows, assume tests will also end in '.exe'.\n        exe_suffix = str(test_suffix)\n        if kIsWindows:\n            exe_suffix += '.exe'\n        # Also check for .py files for testing purposes.\n        self.test_suffixes = {exe_suffix, test_suffix + '.py'}",
        "detail": "src.libcxx.utils.libcxx.test.googlebenchmark",
        "documentation": {}
    },
    {
        "label": "kIsWindows",
        "kind": 5,
        "importPath": "src.libcxx.utils.libcxx.test.googlebenchmark",
        "description": "src.libcxx.utils.libcxx.test.googlebenchmark",
        "peekOfCode": "kIsWindows = sys.platform in ['win32', 'cygwin']\nclass GoogleBenchmark(TestFormat):\n    def __init__(self, test_sub_dirs, test_suffix, benchmark_args=[]):\n        self.benchmark_args = list(benchmark_args)\n        self.test_sub_dirs = os.path.normcase(str(test_sub_dirs)).split(';')\n        # On Windows, assume tests will also end in '.exe'.\n        exe_suffix = str(test_suffix)\n        if kIsWindows:\n            exe_suffix += '.exe'\n        # Also check for .py files for testing purposes.",
        "detail": "src.libcxx.utils.libcxx.test.googlebenchmark",
        "documentation": {}
    },
    {
        "label": "configure",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.newconfig",
        "description": "src.libcxx.utils.libcxx.test.newconfig",
        "peekOfCode": "def configure(parameters, features, config, lit_config):\n  note = lambda s: lit_config.note(\"({}) {}\".format(config.name, s))\n  config.environment = dict(os.environ)\n  # Apply the actions supplied by parameters to the configuration first, since\n  # parameters are things that we request explicitly and which might influence\n  # what features are implicitly made available next.\n  for param in parameters:\n    actions = param.getActions(config, lit_config.params)\n    for action in actions:\n      action.applyTo(config)",
        "detail": "src.libcxx.utils.libcxx.test.newconfig",
        "documentation": {}
    },
    {
        "label": "getStdFlag",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.params",
        "description": "src.libcxx.utils.libcxx.test.params",
        "peekOfCode": "def getStdFlag(cfg, std):\n  fallbacks = {\n    'c++11': 'c++0x',\n    'c++14': 'c++1y',\n    'c++17': 'c++1z',\n    'c++20': 'c++2a',\n  }\n  if hasCompileFlag(cfg, '-std='+std):\n    return '-std='+std\n  if std in fallbacks and hasCompileFlag(cfg, '-std='+fallbacks[std]):",
        "detail": "src.libcxx.utils.libcxx.test.params",
        "documentation": {}
    },
    {
        "label": "_warningFlags",
        "kind": 5,
        "importPath": "src.libcxx.utils.libcxx.test.params",
        "description": "src.libcxx.utils.libcxx.test.params",
        "peekOfCode": "_warningFlags = [\n  '-Werror',\n  '-Wall',\n  '-Wextra',\n  '-Wshadow',\n  '-Wundef',\n  '-Wno-unused-command-line-argument',\n  '-Wno-attributes',\n  '-Wno-pessimizing-move',\n  '-Wno-c++11-extensions',",
        "detail": "src.libcxx.utils.libcxx.test.params",
        "documentation": {}
    },
    {
        "label": "_allStandards",
        "kind": 5,
        "importPath": "src.libcxx.utils.libcxx.test.params",
        "description": "src.libcxx.utils.libcxx.test.params",
        "peekOfCode": "_allStandards = ['c++03', 'c++11', 'c++14', 'c++17', 'c++20', 'c++2b']\ndef getStdFlag(cfg, std):\n  fallbacks = {\n    'c++11': 'c++0x',\n    'c++14': 'c++1y',\n    'c++17': 'c++1z',\n    'c++20': 'c++2a',\n  }\n  if hasCompileFlag(cfg, '-std='+std):\n    return '-std='+std",
        "detail": "src.libcxx.utils.libcxx.test.params",
        "documentation": {}
    },
    {
        "label": "DEFAULT_PARAMETERS",
        "kind": 5,
        "importPath": "src.libcxx.utils.libcxx.test.params",
        "description": "src.libcxx.utils.libcxx.test.params",
        "peekOfCode": "DEFAULT_PARAMETERS = [\n  Parameter(name='target_triple', type=str,\n            help=\"The target triple to compile the test suite for. This must be \"\n                 \"compatible with the target that the tests will be run on.\",\n            actions=lambda triple: filter(None, [\n              AddFeature('target={}'.format(triple)),\n              AddFlagIfSupported('--target={}'.format(triple)),\n              AddSubstitution('%{triple}', triple)\n            ])),\n  Parameter(name='std', choices=_allStandards, type=str,",
        "detail": "src.libcxx.utils.libcxx.test.params",
        "documentation": {}
    },
    {
        "label": "DefaultTargetInfo",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.target_info",
        "description": "src.libcxx.utils.libcxx.test.target_info",
        "peekOfCode": "class DefaultTargetInfo(object):\n    def __init__(self, full_config):\n        self.full_config = full_config\n        self.executor = None\n    def is_windows(self):\n        return False\n    def is_zos(self):\n        return False\n    def is_mingw(self):\n        return False",
        "detail": "src.libcxx.utils.libcxx.test.target_info",
        "documentation": {}
    },
    {
        "label": "DarwinLocalTI",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.target_info",
        "description": "src.libcxx.utils.libcxx.test.target_info",
        "peekOfCode": "class DarwinLocalTI(DefaultTargetInfo):\n    def __init__(self, full_config):\n        super(DarwinLocalTI, self).__init__(full_config)\n    def add_cxx_flags(self, flags):\n        out, err, exit_code = executeCommand(['xcrun', '--show-sdk-path'])\n        if exit_code != 0:\n            self.full_config.lit_config.warning(\"Could not determine macOS SDK path! stderr was \" + err)\n        if exit_code == 0 and out:\n            sdk_path = out.strip()\n            self.full_config.lit_config.note('using SDKROOT: %r' % sdk_path)",
        "detail": "src.libcxx.utils.libcxx.test.target_info",
        "documentation": {}
    },
    {
        "label": "FreeBSDLocalTI",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.target_info",
        "description": "src.libcxx.utils.libcxx.test.target_info",
        "peekOfCode": "class FreeBSDLocalTI(DefaultTargetInfo):\n    def __init__(self, full_config):\n        super(FreeBSDLocalTI, self).__init__(full_config)\n    def add_cxx_link_flags(self, flags):\n        flags += ['-lc', '-lm', '-lpthread', '-lgcc_s', '-lcxxrt']\nclass NetBSDLocalTI(DefaultTargetInfo):\n    def __init__(self, full_config):\n        super(NetBSDLocalTI, self).__init__(full_config)\n    def add_cxx_link_flags(self, flags):\n        flags += ['-lc', '-lm', '-lpthread', '-lgcc_s', '-lc++abi',",
        "detail": "src.libcxx.utils.libcxx.test.target_info",
        "documentation": {}
    },
    {
        "label": "NetBSDLocalTI",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.target_info",
        "description": "src.libcxx.utils.libcxx.test.target_info",
        "peekOfCode": "class NetBSDLocalTI(DefaultTargetInfo):\n    def __init__(self, full_config):\n        super(NetBSDLocalTI, self).__init__(full_config)\n    def add_cxx_link_flags(self, flags):\n        flags += ['-lc', '-lm', '-lpthread', '-lgcc_s', '-lc++abi',\n                  '-lunwind']\nclass LinuxLocalTI(DefaultTargetInfo):\n    def __init__(self, full_config):\n        super(LinuxLocalTI, self).__init__(full_config)\n    def add_cxx_compile_flags(self, flags):",
        "detail": "src.libcxx.utils.libcxx.test.target_info",
        "documentation": {}
    },
    {
        "label": "LinuxLocalTI",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.target_info",
        "description": "src.libcxx.utils.libcxx.test.target_info",
        "peekOfCode": "class LinuxLocalTI(DefaultTargetInfo):\n    def __init__(self, full_config):\n        super(LinuxLocalTI, self).__init__(full_config)\n    def add_cxx_compile_flags(self, flags):\n        flags += ['-D__STDC_FORMAT_MACROS',\n                  '-D__STDC_LIMIT_MACROS',\n                  '-D__STDC_CONSTANT_MACROS']\n    def add_cxx_link_flags(self, flags):\n        enable_threads = ('no-threads' not in\n                          self.full_config.config.available_features)",
        "detail": "src.libcxx.utils.libcxx.test.target_info",
        "documentation": {}
    },
    {
        "label": "LinuxRemoteTI",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.target_info",
        "description": "src.libcxx.utils.libcxx.test.target_info",
        "peekOfCode": "class LinuxRemoteTI(LinuxLocalTI):\n    def __init__(self, full_config):\n        super(LinuxRemoteTI, self).__init__(full_config)\nclass WindowsLocalTI(DefaultTargetInfo):\n    def __init__(self, full_config):\n        super(WindowsLocalTI, self).__init__(full_config)\n    def is_windows(self):\n        return True\nclass ZOSLocalTI(DefaultTargetInfo):\n    def __init__(self, full_config):",
        "detail": "src.libcxx.utils.libcxx.test.target_info",
        "documentation": {}
    },
    {
        "label": "WindowsLocalTI",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.target_info",
        "description": "src.libcxx.utils.libcxx.test.target_info",
        "peekOfCode": "class WindowsLocalTI(DefaultTargetInfo):\n    def __init__(self, full_config):\n        super(WindowsLocalTI, self).__init__(full_config)\n    def is_windows(self):\n        return True\nclass ZOSLocalTI(DefaultTargetInfo):\n    def __init__(self, full_config):\n        super(ZOSLocalTI, self).__init__(full_config)\n    def is_zos(self):\n        return True",
        "detail": "src.libcxx.utils.libcxx.test.target_info",
        "documentation": {}
    },
    {
        "label": "ZOSLocalTI",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.target_info",
        "description": "src.libcxx.utils.libcxx.test.target_info",
        "peekOfCode": "class ZOSLocalTI(DefaultTargetInfo):\n    def __init__(self, full_config):\n        super(ZOSLocalTI, self).__init__(full_config)\n    def is_zos(self):\n        return True\nclass MingwLocalTI(WindowsLocalTI):\n    def __init__(self, full_config):\n        super(MingwLocalTI, self).__init__(full_config)\n    def is_mingw(self):\n        return True",
        "detail": "src.libcxx.utils.libcxx.test.target_info",
        "documentation": {}
    },
    {
        "label": "MingwLocalTI",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.test.target_info",
        "description": "src.libcxx.utils.libcxx.test.target_info",
        "peekOfCode": "class MingwLocalTI(WindowsLocalTI):\n    def __init__(self, full_config):\n        super(MingwLocalTI, self).__init__(full_config)\n    def is_mingw(self):\n        return True\ndef make_target_info(full_config):\n    default = \"libcxx.test.target_info.LocalTI\"\n    info_str = full_config.get_lit_conf('target_info', default)\n    if info_str != default:\n        mod_path, _, info = info_str.rpartition('.')",
        "detail": "src.libcxx.utils.libcxx.test.target_info",
        "documentation": {}
    },
    {
        "label": "make_target_info",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.test.target_info",
        "description": "src.libcxx.utils.libcxx.test.target_info",
        "peekOfCode": "def make_target_info(full_config):\n    default = \"libcxx.test.target_info.LocalTI\"\n    info_str = full_config.get_lit_conf('target_info', default)\n    if info_str != default:\n        mod_path, _, info = info_str.rpartition('.')\n        mod = importlib.import_module(mod_path)\n        target_info = getattr(mod, info)(full_config)\n        full_config.lit_config.note(\"inferred target_info as: %r\" % info_str)\n        return target_info\n    target_system = platform.system()",
        "detail": "src.libcxx.utils.libcxx.test.target_info",
        "documentation": {}
    },
    {
        "label": "CXXCompiler",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.compiler",
        "description": "src.libcxx.utils.libcxx.compiler",
        "peekOfCode": "class CXXCompiler(object):\n    CM_Default = 0\n    CM_PreProcess = 1\n    CM_Compile = 2\n    CM_Link = 3\n    def __init__(self, config, path, flags=None, compile_flags=None, link_flags=None,\n                 warning_flags=None, verify_supported=None,\n                 verify_flags=None, use_verify=False,\n                 modules_flags=None, use_modules=False,\n                 use_ccache=False, use_warnings=False, compile_env=None,",
        "detail": "src.libcxx.utils.libcxx.compiler",
        "documentation": {}
    },
    {
        "label": "ExecuteCommandTimeoutException",
        "kind": 6,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "class ExecuteCommandTimeoutException(Exception):\n    def __init__(self, msg, out, err, exitCode):\n        assert isinstance(msg, str)\n        assert isinstance(out, str)\n        assert isinstance(err, str)\n        assert isinstance(exitCode, int)\n        self.msg = msg\n        self.out = out\n        self.err = err\n        self.exitCode = exitCode",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "to_bytes",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def to_bytes(str):\n    # Encode to UTF-8 to get binary data.\n    if isinstance(str, bytes):\n        return str\n    return str.encode('utf-8')\ndef to_string(bytes):\n    if isinstance(bytes, str):\n        return bytes\n    return to_bytes(bytes)\ndef convert_string(bytes):",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "to_string",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def to_string(bytes):\n    if isinstance(bytes, str):\n        return bytes\n    return to_bytes(bytes)\ndef convert_string(bytes):\n    try:\n        return to_string(bytes.decode('utf-8'))\n    except AttributeError: # 'str' object has no attribute 'decode'.\n        return str(bytes)\n    except UnicodeError:",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "convert_string",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def convert_string(bytes):\n    try:\n        return to_string(bytes.decode('utf-8'))\n    except AttributeError: # 'str' object has no attribute 'decode'.\n        return str(bytes)\n    except UnicodeError:\n        return str(bytes)\ndef cleanFile(filename):\n    try:\n        os.remove(filename)",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "cleanFile",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def cleanFile(filename):\n    try:\n        os.remove(filename)\n    except OSError:\n        pass\n@contextmanager\ndef guardedTempFilename(suffix='', prefix='', dir=None):\n    # Creates and yeilds a temporary filename within a with statement. The file\n    # is removed upon scope exit.\n    handle, name = tempfile.mkstemp(suffix=suffix, prefix=prefix, dir=dir)",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "guardedTempFilename",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def guardedTempFilename(suffix='', prefix='', dir=None):\n    # Creates and yeilds a temporary filename within a with statement. The file\n    # is removed upon scope exit.\n    handle, name = tempfile.mkstemp(suffix=suffix, prefix=prefix, dir=dir)\n    os.close(handle)\n    yield name\n    cleanFile(name)\n@contextmanager\ndef guardedFilename(name):\n    # yeilds a filename within a with statement. The file is removed upon scope",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "guardedFilename",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def guardedFilename(name):\n    # yeilds a filename within a with statement. The file is removed upon scope\n    # exit.\n    yield name\n    cleanFile(name)\n@contextmanager\ndef nullContext(value):\n    # yeilds a variable within a with statement. No action is taken upon scope\n    # exit.\n    yield value",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "nullContext",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def nullContext(value):\n    # yeilds a variable within a with statement. No action is taken upon scope\n    # exit.\n    yield value\ndef makeReport(cmd, out, err, rc):\n    report = \"Command: %s\\n\" % cmd\n    report += \"Exit Code: %d\\n\" % rc\n    if out:\n        report += \"Standard Output:\\n--\\n%s--\\n\" % out\n    if err:",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "makeReport",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def makeReport(cmd, out, err, rc):\n    report = \"Command: %s\\n\" % cmd\n    report += \"Exit Code: %d\\n\" % rc\n    if out:\n        report += \"Standard Output:\\n--\\n%s--\\n\" % out\n    if err:\n        report += \"Standard Error:\\n--\\n%s--\\n\" % err\n    report += '\\n'\n    return report\ndef capture(args, env=None):",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "capture",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def capture(args, env=None):\n    \"\"\"capture(command) - Run the given command (or argv list) in a shell and\n    return the standard output. Raises a CalledProcessError if the command\n    exits with a non-zero status.\"\"\"\n    p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n                         env=env)\n    out, err = p.communicate()\n    out = convert_string(out)\n    err = convert_string(err)\n    if p.returncode != 0:",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "which",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def which(command, paths = None):\n    \"\"\"which(command, [paths]) - Look up the given command in the paths string\n    (or the PATH environment variable, if unspecified).\"\"\"\n    if paths is None:\n        paths = os.environ.get('PATH', '')\n    # Check for absolute match first.\n    if os.path.isfile(command):\n        return command\n    # Would be nice if Python had a lib function for this.\n    if not paths:",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "checkToolsPath",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def checkToolsPath(dir, tools):\n    for tool in tools:\n        if not os.path.exists(os.path.join(dir, tool)):\n            return False\n    return True\ndef whichTools(tools, paths):\n    for path in paths.split(os.pathsep):\n        if checkToolsPath(path, tools):\n            return path\n    return None",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "whichTools",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def whichTools(tools, paths):\n    for path in paths.split(os.pathsep):\n        if checkToolsPath(path, tools):\n            return path\n    return None\ndef mkdir_p(path):\n    \"\"\"mkdir_p(path) - Make the \"path\" directory, if it does not exist; this\n    will also make directories for any missing parent directories.\"\"\"\n    if not path or os.path.exists(path):\n        return",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "mkdir_p",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def mkdir_p(path):\n    \"\"\"mkdir_p(path) - Make the \"path\" directory, if it does not exist; this\n    will also make directories for any missing parent directories.\"\"\"\n    if not path or os.path.exists(path):\n        return\n    parent = os.path.dirname(path)\n    if parent != path:\n        mkdir_p(parent)\n    try:\n        os.mkdir(path)",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "executeCommand",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def executeCommand(command, cwd=None, env=None, input=None, timeout=0):\n    \"\"\"\n        Execute command ``command`` (list of arguments or string)\n        with\n        * working directory ``cwd`` (str), use None to use the current\n          working directory\n        * environment ``env`` (dict), use None for none\n        * Input to the command ``input`` (str), use string to pass\n          no input.\n        * Max execution time ``timeout`` (int) seconds. Use 0 for no timeout.",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "killProcessAndChildren",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def killProcessAndChildren(pid):\n    \"\"\"\n    This function kills a process with ``pid`` and all its\n    running children (recursively). It is currently implemented\n    using the psutil module which provides a simple platform\n    neutral implementation.\n    TODO: Reimplement this without using psutil so we can\n          remove our dependency on it.\n    \"\"\"\n    if platform.system() == 'AIX':",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "executeCommandVerbose",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def executeCommandVerbose(cmd, *args, **kwargs):\n    \"\"\"\n    Execute a command and print its output on failure.\n    \"\"\"\n    out, err, exitCode = executeCommand(cmd, *args, **kwargs)\n    if exitCode != 0:\n        report = makeReport(cmd, out, err, exitCode)\n        report += \"\\n\\nFailed!\"\n        sys.stderr.write('%s\\n' % report)\n    return out, err, exitCode",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "executeCommandOrDie",
        "kind": 2,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "def executeCommandOrDie(cmd, *args, **kwargs):\n    \"\"\"\n    Execute a command and print its output on failure.\n    \"\"\"\n    out, err, exitCode = executeCommand(cmd, *args, **kwargs)\n    if exitCode != 0:\n        report = makeReport(cmd, out, err, exitCode)\n        report += \"\\n\\nFailed!\"\n        sys.stderr.write('%s\\n' % report)\n        sys.exit(exitCode)",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "kUseCloseFDs",
        "kind": 5,
        "importPath": "src.libcxx.utils.libcxx.util",
        "description": "src.libcxx.utils.libcxx.util",
        "peekOfCode": "kUseCloseFDs = not (platform.system() == 'Windows')\ndef executeCommand(command, cwd=None, env=None, input=None, timeout=0):\n    \"\"\"\n        Execute command ``command`` (list of arguments or string)\n        with\n        * working directory ``cwd`` (str), use None to use the current\n          working directory\n        * environment ``env`` (dict), use None for none\n        * Input to the command ``input`` (str), use string to pass\n          no input.",
        "detail": "src.libcxx.utils.libcxx.util",
        "documentation": {}
    },
    {
        "label": "print_and_exit",
        "kind": 2,
        "importPath": "src.libcxx.utils.cat_files",
        "description": "src.libcxx.utils.cat_files",
        "peekOfCode": "def print_and_exit(msg):\n    sys.stderr.write(msg + '\\n')\n    sys.exit(1)\ndef main():\n    parser = ArgumentParser(\n        description=\"Concatenate two files into a single file\")\n    parser.add_argument(\n        '-o', '--output', dest='output', required=True,\n        help='The output file. stdout is used if not given',\n        type=str, action='store')",
        "detail": "src.libcxx.utils.cat_files",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.libcxx.utils.cat_files",
        "description": "src.libcxx.utils.cat_files",
        "peekOfCode": "def main():\n    parser = ArgumentParser(\n        description=\"Concatenate two files into a single file\")\n    parser.add_argument(\n        '-o', '--output', dest='output', required=True,\n        help='The output file. stdout is used if not given',\n        type=str, action='store')\n    parser.add_argument(\n        'files', metavar='files',  nargs='+',\n        help='The files to concatenate')",
        "detail": "src.libcxx.utils.cat_files",
        "documentation": {}
    },
    {
        "label": "OutputFile",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_abi_list",
        "description": "src.libcxx.utils.generate_abi_list",
        "peekOfCode": "def OutputFile(file):\n    if isinstance(file, io.IOBase):\n        return file\n    assert isinstance(file, str), \"Got object {} which is not a str\".format(file)\n    return open(file, 'w', newline='\\n')\ndef main(argv):\n    parser = argparse.ArgumentParser(\n        description='Extract a list of symbols from a shared library.')\n    parser.add_argument('library', metavar='LIB', type=str,\n        help='The library to extract symbols from.')",
        "detail": "src.libcxx.utils.generate_abi_list",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_abi_list",
        "description": "src.libcxx.utils.generate_abi_list",
        "peekOfCode": "def main(argv):\n    parser = argparse.ArgumentParser(\n        description='Extract a list of symbols from a shared library.')\n    parser.add_argument('library', metavar='LIB', type=str,\n        help='The library to extract symbols from.')\n    parser.add_argument('-o', '--output', dest='output', type=OutputFile, default=sys.stdout,\n        help='The output file to write the symbols to. It is overwritten if it already exists. '\n             'If no file is specified, the results are written to standard output.')\n    args = parser.parse_args(argv)\n    symbols = libcxx.sym_check.extract.extract_symbols(args.library)",
        "detail": "src.libcxx.utils.generate_abi_list",
        "documentation": {}
    },
    {
        "label": "PropertyRange",
        "kind": 6,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "peekOfCode": "class PropertyRange:\n    lower: int = -1\n    upper: int = -1\n    prop: str = None\n@dataclass\nclass Entry:\n    lower: int = -1\n    offset: int = -1\n    prop: int = -1\nLINE_REGEX = re.compile(",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "documentation": {}
    },
    {
        "label": "Entry",
        "kind": 6,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "peekOfCode": "class Entry:\n    lower: int = -1\n    offset: int = -1\n    prop: int = -1\nLINE_REGEX = re.compile(\n    r\"^(?P<lower>[0-9A-F]{4,5})(?:\\.\\.(?P<upper>[0-9A-F]{4,5}))?\\s*;\\s*(?P<prop>\\w+)\"\n)\ndef parsePropertyLine(inputLine: str) -> Optional[PropertyRange]:\n    result = PropertyRange()\n    if m := LINE_REGEX.match(inputLine):",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "documentation": {}
    },
    {
        "label": "parsePropertyLine",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "peekOfCode": "def parsePropertyLine(inputLine: str) -> Optional[PropertyRange]:\n    result = PropertyRange()\n    if m := LINE_REGEX.match(inputLine):\n        lower_str, upper_str, result.prop = m.group(\"lower\", \"upper\", \"prop\")\n        result.lower = int(lower_str, base=16)\n        result.upper = result.lower\n        if upper_str is not None:\n            result.upper = int(upper_str, base=16)\n        return result\n    else:",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "documentation": {}
    },
    {
        "label": "compactPropertyRanges",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "peekOfCode": "def compactPropertyRanges(input: list[PropertyRange]) -> list[PropertyRange]:\n    \"\"\"\n    Merges consecutive ranges with the same property to one range.\n    Merging the ranges results in fewer ranges in the output table,\n    reducing binary and improving lookup performance.\n    \"\"\"\n    result = list()\n    for x in input:\n        if (\n            len(result)",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "documentation": {}
    },
    {
        "label": "property_ranges_to_table",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "peekOfCode": "def property_ranges_to_table(\n    ranges: list[PropertyRange], props: list[str]\n) -> list[Entry]:\n    assert len(props) < 16\n    result = list[Entry]()\n    high = -1\n    for range in sorted(ranges, key=lambda x: x.lower):\n        # Validate overlapping ranges\n        assert range.lower > high\n        high = range.upper",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "documentation": {}
    },
    {
        "label": "generate_cpp_data",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "peekOfCode": "def generate_cpp_data(prop_name: str, ranges: list[PropertyRange]) -> str:\n    result = StringIO()\n    prop_values = sorted(set(x.prop for x in ranges))\n    table = property_ranges_to_table(ranges, prop_values)\n    enumerator_values = [PROP_VALUE_ENUMERATOR_TEMPLATE.format(x) for x in prop_values]\n    result.write(\n        PROP_VALUE_ENUM_TEMPLATE.format(enumerators=\",\".join(enumerator_values))\n    )\n    result.write(\n        DATA_ARRAY_TEMPLATE.format(",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "documentation": {}
    },
    {
        "label": "generate_data_tables",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "peekOfCode": "def generate_data_tables() -> str:\n    \"\"\"\n    Generate Unicode data for inclusion into <format> from\n    GraphemeBreakProperty.txt and emoji-data.txt.\n    GraphemeBreakProperty.txt can be found at\n    https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n    emoji-data.txt can be found at\n    https://www.unicode.org/Public/UCD/latest/ucd/emoji/emoji-data.txt\n    Both files are expected to be in the same directory as this script.\n    \"\"\"",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "documentation": {}
    },
    {
        "label": "LINE_REGEX",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "peekOfCode": "LINE_REGEX = re.compile(\n    r\"^(?P<lower>[0-9A-F]{4,5})(?:\\.\\.(?P<upper>[0-9A-F]{4,5}))?\\s*;\\s*(?P<prop>\\w+)\"\n)\ndef parsePropertyLine(inputLine: str) -> Optional[PropertyRange]:\n    result = PropertyRange()\n    if m := LINE_REGEX.match(inputLine):\n        lower_str, upper_str, result.prop = m.group(\"lower\", \"upper\", \"prop\")\n        result.lower = int(lower_str, base=16)\n        result.upper = result.lower\n        if upper_str is not None:",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "documentation": {}
    },
    {
        "label": "PROP_VALUE_ENUMERATOR_TEMPLATE",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "peekOfCode": "PROP_VALUE_ENUMERATOR_TEMPLATE = \"__{}\"\nPROP_VALUE_ENUM_TEMPLATE = \"\"\"\nenum class __property : uint8_t {{\n  // Values generated from the data files.\n  {enumerators},\n  // The properies below aren't stored in the \"database\".\n  // Text position properties.\n  __sot,\n  __eot,\n  // The code unit has none of above properties.",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "documentation": {}
    },
    {
        "label": "PROP_VALUE_ENUM_TEMPLATE",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "peekOfCode": "PROP_VALUE_ENUM_TEMPLATE = \"\"\"\nenum class __property : uint8_t {{\n  // Values generated from the data files.\n  {enumerators},\n  // The properies below aren't stored in the \"database\".\n  // Text position properties.\n  __sot,\n  __eot,\n  // The code unit has none of above properties.\n  __none",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "documentation": {}
    },
    {
        "label": "DATA_ARRAY_TEMPLATE",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "peekOfCode": "DATA_ARRAY_TEMPLATE = \"\"\"\n/// The entries of the extended grapheme cluster bondary property table.\n///\n/// The data is generated from\n/// - https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n/// - https://www.unicode.org/Public/UCD/latest/ucd/emoji/emoji-data.txt\n///\n/// The data has 3 values\n/// - bits [0, 3] The property. One of the values generated form the datafiles\n///   of \\\\ref __property",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "documentation": {}
    },
    {
        "label": "MSVC_FORMAT_UCD_TABLES_HPP_TEMPLATE",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "peekOfCode": "MSVC_FORMAT_UCD_TABLES_HPP_TEMPLATE = \"\"\"\n// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// WARNING, this entire header is generated by",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "documentation": {}
    },
    {
        "label": "cpp_entrytemplate",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "peekOfCode": "cpp_entrytemplate = \"0x{:08x}\"\ndef generate_cpp_data(prop_name: str, ranges: list[PropertyRange]) -> str:\n    result = StringIO()\n    prop_values = sorted(set(x.prop for x in ranges))\n    table = property_ranges_to_table(ranges, prop_values)\n    enumerator_values = [PROP_VALUE_ENUMERATOR_TEMPLATE.format(x) for x in prop_values]\n    result.write(\n        PROP_VALUE_ENUM_TEMPLATE.format(enumerators=\",\".join(enumerator_values))\n    )\n    result.write(",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_table",
        "documentation": {}
    },
    {
        "label": "BreakTestItem",
        "kind": 6,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "peekOfCode": "class BreakTestItem:\n    code_points: list[int] = field(default_factory=list)\n    encoded: str = \"\"\n    breaks_utf8: list[int] = field(default_factory=list)\n    breaks_utf16: list[int] = field(default_factory=list)\n    breaks_utf32: list[int] = field(default_factory=list)\nclass CommentLine:\n    pass\nclass EOF:\n    pass",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "documentation": {}
    },
    {
        "label": "CommentLine",
        "kind": 6,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "peekOfCode": "class CommentLine:\n    pass\nclass EOF:\n    pass\ndef parseBreakTestLine(input: TextIO) -> Optional[BreakTestItem]:\n    result = BreakTestItem()\n    code_point = -1\n    utf8 = 0\n    utf16 = 0\n    utf32 = 0",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "documentation": {}
    },
    {
        "label": "EOF",
        "kind": 6,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "peekOfCode": "class EOF:\n    pass\ndef parseBreakTestLine(input: TextIO) -> Optional[BreakTestItem]:\n    result = BreakTestItem()\n    code_point = -1\n    utf8 = 0\n    utf16 = 0\n    utf32 = 0\n    while True:\n        c = input.read(1)",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "documentation": {}
    },
    {
        "label": "parseBreakTestLine",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "peekOfCode": "def parseBreakTestLine(input: TextIO) -> Optional[BreakTestItem]:\n    result = BreakTestItem()\n    code_point = -1\n    utf8 = 0\n    utf16 = 0\n    utf32 = 0\n    while True:\n        c = input.read(1)\n        if c == \"\\N{DIVISION SIGN}\":\n            # The line starts with a division sign, don't add it to the output.",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "documentation": {}
    },
    {
        "label": "lineToCppDataLineUtf8",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "peekOfCode": "def lineToCppDataLineUtf8(line: BreakTestItem) -> str:\n    return cpp_test_data_line_template.format(\n        f'\"{line.encoded}\"',\n        \",\".join([str(x) for x in line.code_points]),\n        \",\".join([str(x) for x in line.breaks_utf8]),\n    )\ndef lineToCppDataLineUtf16(line: BreakTestItem) -> str:\n    return cpp_test_data_line_template.format(\n        f'L\"{line.encoded}\"',\n        \",\".join([str(x) for x in line.code_points]),",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "documentation": {}
    },
    {
        "label": "lineToCppDataLineUtf16",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "peekOfCode": "def lineToCppDataLineUtf16(line: BreakTestItem) -> str:\n    return cpp_test_data_line_template.format(\n        f'L\"{line.encoded}\"',\n        \",\".join([str(x) for x in line.code_points]),\n        \",\".join([str(x) for x in line.breaks_utf16]),\n    )\ndef lineToCppDataLineUtf32(line: BreakTestItem) -> str:\n    return cpp_test_data_line_template.format(\n        f'L\"{line.encoded}\"',\n        \",\".join([str(x) for x in line.code_points]),",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "documentation": {}
    },
    {
        "label": "lineToCppDataLineUtf32",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "peekOfCode": "def lineToCppDataLineUtf32(line: BreakTestItem) -> str:\n    return cpp_test_data_line_template.format(\n        f'L\"{line.encoded}\"',\n        \",\".join([str(x) for x in line.code_points]),\n        \",\".join([str(x) for x in line.breaks_utf32]),\n    )\n\"\"\"\nGenerate test data from \"GraphemeBreakText.txt\"\nThis file can be downloaded from:\nhttps://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "documentation": {}
    },
    {
        "label": "generate_all",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "peekOfCode": "def generate_all() -> str:\n    test_data_path = Path(__file__)\n    test_data_path = test_data_path.absolute()\n    test_data_path = test_data_path.with_name(\"GraphemeBreakTest.txt\")\n    lines = list()\n    with open(test_data_path, mode=\"rt\", encoding=\"utf-8\") as file:\n        while line := parseBreakTestLine(file):\n            if len(line.encoded) > 0:\n                lines.append(line)\n    return cpp_template.format(",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "documentation": {}
    },
    {
        "label": "cpp_template",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "peekOfCode": "cpp_template = \"\"\"// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// WARNING, this entire header is generated by\n// utiles/generate_extended_grapheme_cluster_test.py",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "documentation": {}
    },
    {
        "label": "cpp_test_data_line_template",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "description": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "peekOfCode": "cpp_test_data_line_template = \"{{ {}, {{ {} }}, {{ {} }} }}\"\ndef lineToCppDataLineUtf8(line: BreakTestItem) -> str:\n    return cpp_test_data_line_template.format(\n        f'\"{line.encoded}\"',\n        \",\".join([str(x) for x in line.code_points]),\n        \",\".join([str(x) for x in line.breaks_utf8]),\n    )\ndef lineToCppDataLineUtf16(line: BreakTestItem) -> str:\n    return cpp_test_data_line_template.format(\n        f'L\"{line.encoded}\"',",
        "detail": "src.libcxx.utils.generate_extended_grapheme_cluster_test",
        "documentation": {}
    },
    {
        "label": "get_libcxx_paths",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def get_libcxx_paths():\n  utils_path = os.path.dirname(os.path.abspath(__file__))\n  script_name = os.path.basename(__file__)\n  assert os.path.exists(utils_path)\n  src_root = os.path.dirname(utils_path)\n  include_path = os.path.join(src_root, 'include')\n  assert os.path.exists(include_path)\n  docs_path = os.path.join(src_root, 'docs')\n  assert os.path.exists(docs_path)\n  macro_test_path = os.path.join(src_root, 'test', 'std', 'language.support',",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "has_header",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def has_header(h):\n  h_path = os.path.join(include_path, h)\n  return os.path.exists(h_path)\ndef add_version_header(tc):\n  tc[\"headers\"].append(\"version\")\n  return tc\n# ================  ============================================================\n# Field             Description\n# ================  ============================================================\n# name              The name of the feature-test macro.",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "add_version_header",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def add_version_header(tc):\n  tc[\"headers\"].append(\"version\")\n  return tc\n# ================  ============================================================\n# Field             Description\n# ================  ============================================================\n# name              The name of the feature-test macro.\n# values            A dict whose keys are C++ versions and whose values are the\n#                   value of the feature-test macro for that C++ version.\n#                   (TODO: This isn't a very clean model for feature-test",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "get_std_dialects",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def get_std_dialects():\n  std_dialects = ['c++14', 'c++17', 'c++20', 'c++2b']\n  return list(std_dialects)\ndef get_first_std(d):\n    for s in get_std_dialects():\n        if s in d.keys():\n            return s\n    return None\ndef get_last_std(d):\n  rev_dialects = get_std_dialects()",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "get_first_std",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def get_first_std(d):\n    for s in get_std_dialects():\n        if s in d.keys():\n            return s\n    return None\ndef get_last_std(d):\n  rev_dialects = get_std_dialects()\n  rev_dialects.reverse()\n  for s in rev_dialects:\n    if s in d.keys():",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "get_last_std",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def get_last_std(d):\n  rev_dialects = get_std_dialects()\n  rev_dialects.reverse()\n  for s in rev_dialects:\n    if s in d.keys():\n      return s\n  return None\ndef get_std_before(d, std):\n  std_dialects = get_std_dialects()\n  candidates = std_dialects[0:std_dialects.index(std)]",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "get_std_before",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def get_std_before(d, std):\n  std_dialects = get_std_dialects()\n  candidates = std_dialects[0:std_dialects.index(std)]\n  candidates.reverse()\n  for cand in candidates:\n    if cand in d.keys():\n      return cand\n  return None\ndef get_value_before(d, std):\n  new_std = get_std_before(d, std)",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "get_value_before",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def get_value_before(d, std):\n  new_std = get_std_before(d, std)\n  if new_std is None:\n    return None\n  return d[new_std]\ndef get_for_std(d, std):\n  # This catches the C++11 case for which there should be no defined feature\n  # test macros.\n  std_dialects = get_std_dialects()\n  if std not in std_dialects:",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "get_for_std",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def get_for_std(d, std):\n  # This catches the C++11 case for which there should be no defined feature\n  # test macros.\n  std_dialects = get_std_dialects()\n  if std not in std_dialects:\n    return None\n  # Find the value for the newest C++ dialect between C++14 and std\n  std_list = list(std_dialects[0:std_dialects.index(std)+1])\n  std_list.reverse()\n  for s in std_list:",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "get_std_number",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def get_std_number(std):\n    return std.replace('c++', '')\n\"\"\"\n  Functions to produce the <version> header\n\"\"\"\ndef produce_macros_definition_for_std(std):\n  result = \"\"\n  indent = 55\n  for tc in feature_test_macros:\n    if std not in tc[\"values\"]:",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "produce_macros_definition_for_std",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def produce_macros_definition_for_std(std):\n  result = \"\"\n  indent = 55\n  for tc in feature_test_macros:\n    if std not in tc[\"values\"]:\n      continue\n    inner_indent = 1\n    if 'test_suite_guard' in tc.keys():\n      result += \"# if %s\\n\" % tc[\"libcxx_guard\"]\n      inner_indent += 2",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "produce_macros_definitions",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def produce_macros_definitions():\n  macro_definition_template = \"\"\"#if _LIBCPP_STD_VER > {previous_std_number}\n{macro_definition}\n#endif\"\"\"\n  macros_definitions = []\n  previous_std_number = '11'\n  for std in get_std_dialects():\n    macros_definitions.append(\n      macro_definition_template.format(previous_std_number=previous_std_number,\n                                       macro_definition=produce_macros_definition_for_std(std)))",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "chunks",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def chunks(l, n):\n  \"\"\"Yield successive n-sized chunks from l.\"\"\"\n  for i in range(0, len(l), n):\n    yield l[i:i + n]\ndef produce_version_synopsis():\n  indent = 56\n  header_indent = 56 + len(\"20XXYYL \")\n  result = \"\"\n  def indent_to(s, val):\n    if len(s) >= val:",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "produce_version_synopsis",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def produce_version_synopsis():\n  indent = 56\n  header_indent = 56 + len(\"20XXYYL \")\n  result = \"\"\n  def indent_to(s, val):\n    if len(s) >= val:\n      return s\n    s += \" \" * (val - len(s))\n    return s\n  line = indent_to(\"Macro name\", indent) + \"Value\"",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "produce_version_header",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def produce_version_header():\n  template=\"\"\"// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n#ifndef _LIBCPP_VERSIONH",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "generate_std_test",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def generate_std_test(test_list, std):\n  result = \"\"\n  for tc in test_list:\n    val = get_for_std(tc[\"values\"], std)\n    if val is not None:\n      val = \"%sL\" % val\n    if val is None:\n      result += test_types[\"undefined\"].format(name=tc[\"name\"], std_first=get_first_std(tc[\"values\"]))\n    elif 'unimplemented' in tc.keys():\n      result += test_types[\"unimplemented\"].format(name=tc[\"name\"], value=val, std=std)",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "generate_std_tests",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def generate_std_tests(test_list):\n  std_tests_template = \"\"\"#if TEST_STD_VER < {first_std_number}\n{pre_std_test}\n{other_std_tests}\n#elif TEST_STD_VER > {penultimate_std_number}\n{last_std_test}\n#endif // TEST_STD_VER > {penultimate_std_number}\"\"\"\n  std_dialects = get_std_dialects()\n  assert not get_std_number(std_dialects[-1]).isnumeric()\n  other_std_tests = []",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "generate_synopsis",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def generate_synopsis(test_list):\n    max_name_len = max([len(tc[\"name\"]) for tc in test_list])\n    indent = max_name_len + 8\n    def mk_line(prefix, suffix):\n        return \"{prefix: <{max_len}}{suffix}\\n\".format(prefix=prefix, suffix=suffix,\n        max_len=indent)\n    result = \"\"\n    result += mk_line(\"/*  Constant\", \"Value\")\n    for tc in test_list:\n        prefix = \"    %s\" % tc[\"name\"]",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "produce_tests",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def produce_tests():\n  headers = set([h for tc in feature_test_macros for h in tc[\"headers\"]])\n  for h in headers:\n    test_list = [tc for tc in feature_test_macros if h in tc[\"headers\"]]\n    if not has_header(h):\n      for tc in test_list:\n        assert 'unimplemented' in tc.keys()\n      continue\n    markup = '\\n'.join('// ' + tag for tag in lit_markup.get(h, []))\n    test_body = \\",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "make_widths",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def make_widths(grid):\n  widths = []\n  for i in range(0, len(grid[0])):\n    cell_width = 2 + max(reduce(lambda x,y: x+y, [[len(row[i])] for row in grid], []))\n    widths += [cell_width]\n  return widths\ndef create_table(grid, indent):\n  indent_str = ' '*indent\n  col_widths = make_widths(grid)\n  result = [indent_str + add_divider(col_widths, 2)]",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "create_table",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def create_table(grid, indent):\n  indent_str = ' '*indent\n  col_widths = make_widths(grid)\n  result = [indent_str + add_divider(col_widths, 2)]\n  header_flag = 2\n  for row_i in range(0, len(grid)):\n    row = grid[row_i]\n    line = indent_str + ' '.join([pad_cell(row[i], col_widths[i]) for i in range(0, len(row))])\n    result.append(line.rstrip())\n    is_cxx_header = row[0].startswith('**')",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "add_divider",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def add_divider(widths, header_flag):\n  if header_flag == 2:\n    return ' '.join(['='*w for w in widths])\n  if header_flag == 1:\n    return '-'.join(['-'*w for w in widths])\n  else:\n    return ' '.join(['-'*w for w in widths])\ndef pad_cell(s, length, left_align=True):\n  padding = ((length - len(s)) * ' ')\n  return s + padding",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "pad_cell",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def pad_cell(s, length, left_align=True):\n  padding = ((length - len(s)) * ' ')\n  return s + padding\ndef get_status_table():\n  table = [[\"Macro Name\", \"Value\"]]\n  for std in get_std_dialects():\n    table += [[\"**\" + std.replace(\"c++\", \"C++ \") + \"**\", \"\"]]\n    for tc in feature_test_macros:\n      if std not in tc[\"values\"].keys():\n        continue",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "get_status_table",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def get_status_table():\n  table = [[\"Macro Name\", \"Value\"]]\n  for std in get_std_dialects():\n    table += [[\"**\" + std.replace(\"c++\", \"C++ \") + \"**\", \"\"]]\n    for tc in feature_test_macros:\n      if std not in tc[\"values\"].keys():\n        continue\n      value = \"``%sL``\" % tc[\"values\"][std]\n      if 'unimplemented' in tc.keys():\n        value = '*unimplemented*'",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "produce_docs",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def produce_docs():\n  doc_str = \"\"\".. _FeatureTestMacroTable:\n==========================\nFeature Test Macro Support\n==========================\n.. contents::\n   :local:\nOverview\n========\nThis file documents the feature test macros currently supported by libc++.",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "def main():\n  produce_version_header()\n  produce_tests()\n  produce_docs()\nif __name__ == '__main__':\n  main()",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "feature_test_macros",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "feature_test_macros = [ add_version_header(x) for x in [\n  {\n    \"name\": \"__cpp_lib_adaptor_iterator_pair_constructor\",\n    \"values\": { \"c++2b\": 202106 },\n    \"headers\": [\"queue\", \"stack\"],\n  }, {\n    \"name\": \"__cpp_lib_addressof_constexpr\",\n    \"values\": { \"c++17\": 201603 },\n    \"headers\": [\"memory\"],\n  }, {",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "lit_markup",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "lit_markup = {\n  \"barrier\": [\"UNSUPPORTED: no-threads\"],\n  \"filesystem\": [\"UNSUPPORTED: no-filesystem\"],\n  \"format\": [\"UNSUPPORTED: libcpp-has-no-incomplete-format\"],\n  \"iomanip\": [\"UNSUPPORTED: no-localization\"],\n  \"ios\": [\"UNSUPPORTED: no-localization\"],\n  \"iostream\": [\"UNSUPPORTED: no-localization\"],\n  \"istream\": [\"UNSUPPORTED: no-localization\"],\n  \"latch\": [\"UNSUPPORTED: no-threads\"],\n  \"locale\": [\"UNSUPPORTED: no-localization\"],",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "test_types",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_feature_test_macro_components",
        "description": "src.libcxx.utils.generate_feature_test_macro_components",
        "peekOfCode": "test_types = {\n  \"undefined\": \"\"\"\n# ifdef {name}\n#   error \"{name} should not be defined before {std_first}\"\n# endif\n\"\"\",\n  \"test_suite_guard\": \"\"\"\n# if {test_suite_guard}\n#   ifndef {name}\n#     error \"{name} should be defined in {std}\"",
        "detail": "src.libcxx.utils.generate_feature_test_macro_components",
        "documentation": {}
    },
    {
        "label": "get_libcxx_paths",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_header_inclusion_tests",
        "description": "src.libcxx.utils.generate_header_inclusion_tests",
        "peekOfCode": "def get_libcxx_paths():\n    utils_path = os.path.dirname(os.path.abspath(__file__))\n    script_name = os.path.basename(__file__)\n    assert os.path.exists(utils_path)\n    src_root = os.path.dirname(utils_path)\n    test_path = os.path.join(src_root, 'test', 'libcxx', 'inclusions')\n    assert os.path.exists(test_path)\n    assert os.path.exists(os.path.join(test_path, 'algorithm.inclusions.compile.pass.cpp'))\n    return script_name, src_root, test_path\nscript_name, source_root, test_path = get_libcxx_paths()",
        "detail": "src.libcxx.utils.generate_header_inclusion_tests",
        "documentation": {}
    },
    {
        "label": "get_std_ver_test",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_header_inclusion_tests",
        "description": "src.libcxx.utils.generate_header_inclusion_tests",
        "peekOfCode": "def get_std_ver_test(includee):\n    v = new_in_version.get(includee, \"03\")\n    if v == \"03\":\n        return ''\n    versions = [\"03\", \"11\", \"14\", \"17\", \"20\"]\n    return 'TEST_STD_VER > {} && '.format(max(i for i in versions if i < v))\ndef get_unsupported_line(includee):\n    v = new_in_version.get(includee, \"03\")\n    return {\n        \"03\": [],",
        "detail": "src.libcxx.utils.generate_header_inclusion_tests",
        "documentation": {}
    },
    {
        "label": "get_unsupported_line",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_header_inclusion_tests",
        "description": "src.libcxx.utils.generate_header_inclusion_tests",
        "peekOfCode": "def get_unsupported_line(includee):\n    v = new_in_version.get(includee, \"03\")\n    return {\n        \"03\": [],\n        \"11\": ['UNSUPPORTED: c++03'],\n        \"14\": ['UNSUPPORTED: c++03, c++11'],\n        \"17\": ['UNSUPPORTED: c++03, c++11, c++14'],\n        \"20\": ['UNSUPPORTED: c++03, c++11, c++14, c++17'],\n        \"2b\": ['UNSUPPORTED: c++03, c++11, c++14, c++17, c++20'],\n    }[v]",
        "detail": "src.libcxx.utils.generate_header_inclusion_tests",
        "documentation": {}
    },
    {
        "label": "get_libcpp_header_symbol",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_header_inclusion_tests",
        "description": "src.libcxx.utils.generate_header_inclusion_tests",
        "peekOfCode": "def get_libcpp_header_symbol(header_name):\n    return '_LIBCPP_' + header_name.upper().replace('.', '_')\ndef get_includer_symbol_test(includer):\n    symbol = get_libcpp_header_symbol(includer)\n    return \"\"\"\n#if !defined({symbol})\n #   error \"{message}\"\n#endif\n    \"\"\".strip().format(\n        symbol=symbol,",
        "detail": "src.libcxx.utils.generate_header_inclusion_tests",
        "documentation": {}
    },
    {
        "label": "get_includer_symbol_test",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_header_inclusion_tests",
        "description": "src.libcxx.utils.generate_header_inclusion_tests",
        "peekOfCode": "def get_includer_symbol_test(includer):\n    symbol = get_libcpp_header_symbol(includer)\n    return \"\"\"\n#if !defined({symbol})\n #   error \"{message}\"\n#endif\n    \"\"\".strip().format(\n        symbol=symbol,\n        message=\"<{}> was expected to define {}\".format(includer, symbol),\n    )",
        "detail": "src.libcxx.utils.generate_header_inclusion_tests",
        "documentation": {}
    },
    {
        "label": "get_ifdef",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_header_inclusion_tests",
        "description": "src.libcxx.utils.generate_header_inclusion_tests",
        "peekOfCode": "def get_ifdef(includer, includee):\n    version = max(new_in_version.get(h, \"03\") for h in [includer, includee])\n    symbol = get_libcpp_header_symbol(includee)\n    return \"\"\"\n#if {includee_test}!defined({symbol})\n #   error \"{message}\"\n#endif\n    \"\"\".strip().format(\n        includee_test=get_std_ver_test(includee),\n        symbol=symbol,",
        "detail": "src.libcxx.utils.generate_header_inclusion_tests",
        "documentation": {}
    },
    {
        "label": "produce_tests",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_header_inclusion_tests",
        "description": "src.libcxx.utils.generate_header_inclusion_tests",
        "peekOfCode": "def produce_tests():\n    for includer, includees in mandatory_inclusions.items():\n        markup_tags = get_unsupported_line(includer) + lit_markup.get(includer, [])\n        test_body = test_body_template.format(\n            script_name=script_name,\n            header=includer,\n            markup=('\\n' + '\\n'.join('// ' + m for m in markup_tags) + '\\n') if markup_tags else '',\n            test_includers_symbol=get_includer_symbol_test(includer),\n            test_per_includee='\\n'.join(get_ifdef(includer, includee) for includee in includees),\n        )",
        "detail": "src.libcxx.utils.generate_header_inclusion_tests",
        "documentation": {}
    },
    {
        "label": "mandatory_inclusions",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_header_inclusion_tests",
        "description": "src.libcxx.utils.generate_header_inclusion_tests",
        "peekOfCode": "mandatory_inclusions = {\n    \"algorithm\": [\"initializer_list\"],\n    \"array\": [\"compare\", \"initializer_list\"],\n    \"bitset\": [\"iosfwd\", \"string\"],\n    \"chrono\": [\"compare\"],\n    \"cinttypes\": [\"cstdint\"],\n    \"complex.h\": [\"complex\"],\n    \"coroutine\": [\"compare\"],\n    \"deque\": [\"compare\", \"initializer_list\"],\n    \"filesystem\": [\"compare\"],",
        "detail": "src.libcxx.utils.generate_header_inclusion_tests",
        "documentation": {}
    },
    {
        "label": "new_in_version",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_header_inclusion_tests",
        "description": "src.libcxx.utils.generate_header_inclusion_tests",
        "peekOfCode": "new_in_version = {\n    \"chrono\": \"11\",\n    \"compare\": \"20\",\n    \"concepts\": \"20\",\n    \"coroutine\": \"20\",\n    \"cuchar\": \"11\",\n    \"filesystem\": \"17\",\n    \"initializer_list\": \"11\",\n    \"optional\": \"17\",\n    \"ranges\": \"20\",",
        "detail": "src.libcxx.utils.generate_header_inclusion_tests",
        "documentation": {}
    },
    {
        "label": "lit_markup",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_header_inclusion_tests",
        "description": "src.libcxx.utils.generate_header_inclusion_tests",
        "peekOfCode": "lit_markup = {\n  \"barrier\": [\"UNSUPPORTED: no-threads\"],\n  \"filesystem\": [\"UNSUPPORTED: no-filesystem\"],\n  \"format\": [\"UNSUPPORTED: libcpp-has-no-incomplete-format\"],\n  \"iomanip\": [\"UNSUPPORTED: no-localization\"],\n  \"ios\": [\"UNSUPPORTED: no-localization\"],\n  \"iostream\": [\"UNSUPPORTED: no-localization\"],\n  \"istream\": [\"UNSUPPORTED: no-localization\"],\n  \"latch\": [\"UNSUPPORTED: no-threads\"],\n  \"locale\": [\"UNSUPPORTED: no-localization\"],",
        "detail": "src.libcxx.utils.generate_header_inclusion_tests",
        "documentation": {}
    },
    {
        "label": "test_body_template",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_header_inclusion_tests",
        "description": "src.libcxx.utils.generate_header_inclusion_tests",
        "peekOfCode": "test_body_template = \"\"\"\n//===----------------------------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// WARNING: This test was generated by {script_name}",
        "detail": "src.libcxx.utils.generate_header_inclusion_tests",
        "documentation": {}
    },
    {
        "label": "find_script",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_header_tests",
        "description": "src.libcxx.utils.generate_header_tests",
        "peekOfCode": "def find_script(file):\n    \"\"\"Finds the script used to generate a file inside the file itself. The script is delimited by\n       BEGIN-SCRIPT and END-SCRIPT markers.\n    \"\"\"\n    with open(file, 'r') as f:\n        content = f.read()\n    match = re.search(r'^BEGIN-SCRIPT$(.+)^END-SCRIPT$', content, flags=re.MULTILINE | re.DOTALL)\n    if not match:\n        raise RuntimeError(\"Was unable to find a script delimited with BEGIN-SCRIPT/END-SCRIPT markers in {}\".format(test_file))\n    return match.group(1)",
        "detail": "src.libcxx.utils.generate_header_tests",
        "documentation": {}
    },
    {
        "label": "execute_script",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_header_tests",
        "description": "src.libcxx.utils.generate_header_tests",
        "peekOfCode": "def execute_script(script, variables):\n    \"\"\"Executes the provided Mako template with the given variables available during the\n       evaluation of the script, and returns the result.\n    \"\"\"\n    code = compile(script, 'fake-filename', 'exec')\n    output = io.StringIO()\n    with contextlib.redirect_stdout(output):\n        exec(code, variables)\n        output = output.getvalue()\n    return output",
        "detail": "src.libcxx.utils.generate_header_tests",
        "documentation": {}
    },
    {
        "label": "generate_new_file",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_header_tests",
        "description": "src.libcxx.utils.generate_header_tests",
        "peekOfCode": "def generate_new_file(file, new_content):\n    \"\"\"Generates the new content of the file by inserting the new content in-between\n       two '// GENERATED-MARKER' markers located in the file.\n    \"\"\"\n    with open(file, 'r') as f:\n        old_content = f.read()\n    try:\n        before, begin_marker, _, end_marker, after = re.split(r'(// GENERATED-MARKER\\n)', old_content, flags=re.MULTILINE | re.DOTALL)\n    except ValueError:\n        raise RuntimeError(\"Failed to split {} based on markers, please make sure the file has exactly two '// GENERATED-MARKER' occurrences\".format(file))",
        "detail": "src.libcxx.utils.generate_header_tests",
        "documentation": {}
    },
    {
        "label": "produce",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_header_tests",
        "description": "src.libcxx.utils.generate_header_tests",
        "peekOfCode": "def produce(test_file, variables):\n    script = find_script(test_file)\n    result = execute_script(script, variables)\n    new_content = generate_new_file(test_file, result)\n    with open(test_file, 'w', newline='\\n') as f:\n        f.write(new_content)\ndef is_header(file):\n    \"\"\"Returns whether the given file is a header (i.e. not a directory or the modulemap file).\"\"\"\n    return not file.is_dir() and not file.name == 'module.modulemap.in'\ndef main():",
        "detail": "src.libcxx.utils.generate_header_tests",
        "documentation": {}
    },
    {
        "label": "is_header",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_header_tests",
        "description": "src.libcxx.utils.generate_header_tests",
        "peekOfCode": "def is_header(file):\n    \"\"\"Returns whether the given file is a header (i.e. not a directory or the modulemap file).\"\"\"\n    return not file.is_dir() and not file.name == 'module.modulemap.in'\ndef main():\n    monorepo_root = pathlib.Path(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))\n    include = pathlib.Path(os.path.join(monorepo_root, 'libcxx', 'include'))\n    test = pathlib.Path(os.path.join(monorepo_root, 'libcxx', 'test'))\n    assert(monorepo_root.exists())\n    toplevel_headers     = sorted(str(p.relative_to(include)) for p in include.glob('[a-z]*') if is_header(p))\n    experimental_headers = sorted(str(p.relative_to(include)) for p in include.glob('experimental/[a-z]*') if is_header(p))",
        "detail": "src.libcxx.utils.generate_header_tests",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.libcxx.utils.generate_header_tests",
        "description": "src.libcxx.utils.generate_header_tests",
        "peekOfCode": "def main():\n    monorepo_root = pathlib.Path(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))\n    include = pathlib.Path(os.path.join(monorepo_root, 'libcxx', 'include'))\n    test = pathlib.Path(os.path.join(monorepo_root, 'libcxx', 'test'))\n    assert(monorepo_root.exists())\n    toplevel_headers     = sorted(str(p.relative_to(include)) for p in include.glob('[a-z]*') if is_header(p))\n    experimental_headers = sorted(str(p.relative_to(include)) for p in include.glob('experimental/[a-z]*') if is_header(p))\n    extended_headers     = sorted(str(p.relative_to(include)) for p in include.glob('ext/[a-z]*') if is_header(p))\n    public_headers       = toplevel_headers + experimental_headers + extended_headers\n    private_headers      = sorted(str(p.relative_to(include)) for p in include.rglob('*') if is_header(p) and str(p.relative_to(include)).startswith('__'))",
        "detail": "src.libcxx.utils.generate_header_tests",
        "documentation": {}
    },
    {
        "label": "header_restrictions",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_header_tests",
        "description": "src.libcxx.utils.generate_header_tests",
        "peekOfCode": "header_restrictions = {\n    \"barrier\": \"!defined(_LIBCPP_HAS_NO_THREADS)\",\n    \"future\": \"!defined(_LIBCPP_HAS_NO_THREADS)\",\n    \"latch\": \"!defined(_LIBCPP_HAS_NO_THREADS)\",\n    \"mutex\": \"!defined(_LIBCPP_HAS_NO_THREADS)\",\n    \"semaphore\": \"!defined(_LIBCPP_HAS_NO_THREADS)\",\n    \"shared_mutex\": \"!defined(_LIBCPP_HAS_NO_THREADS)\",\n    \"stdatomic.h\": \"__cplusplus > 202002L && !defined(_LIBCPP_HAS_NO_THREADS)\",\n    \"thread\": \"!defined(_LIBCPP_HAS_NO_THREADS)\",\n    \"filesystem\": \"!defined(_LIBCPP_HAS_NO_FILESYSTEM_LIBRARY)\",",
        "detail": "src.libcxx.utils.generate_header_tests",
        "documentation": {}
    },
    {
        "label": "private_headers_still_public_in_modules",
        "kind": 5,
        "importPath": "src.libcxx.utils.generate_header_tests",
        "description": "src.libcxx.utils.generate_header_tests",
        "peekOfCode": "private_headers_still_public_in_modules = [\n    '__assert', '__bsd_locale_defaults.h', '__bsd_locale_fallbacks.h', '__config',\n    '__config_site.in', '__debug', '__hash_table',\n    '__threading_support', '__tree', '__undef_macros', '__verbose_abort'\n]\ndef find_script(file):\n    \"\"\"Finds the script used to generate a file inside the file itself. The script is delimited by\n       BEGIN-SCRIPT and END-SCRIPT markers.\n    \"\"\"\n    with open(file, 'r') as f:",
        "detail": "src.libcxx.utils.generate_header_tests",
        "documentation": {}
    },
    {
        "label": "FileEntry",
        "kind": 6,
        "importPath": "src.libcxx.utils.graph_header_deps",
        "description": "src.libcxx.utils.graph_header_deps",
        "peekOfCode": "class FileEntry:\n    def __init__(self, includes, individual_linecount):\n        self.includes = includes\n        self.individual_linecount = individual_linecount\n        self.cumulative_linecount = None  # documentation: this gets filled in later\n        self.is_graph_root = None  # documentation: this gets filled in later\ndef list_all_roots_under(root):\n    result = []\n    for root, _, files in os.walk(root):\n        for fname in files:",
        "detail": "src.libcxx.utils.graph_header_deps",
        "documentation": {}
    },
    {
        "label": "is_config_header",
        "kind": 2,
        "importPath": "src.libcxx.utils.graph_header_deps",
        "description": "src.libcxx.utils.graph_header_deps",
        "peekOfCode": "def is_config_header(h):\n    return os.path.basename(h) in ['__config', '__undef_macros', 'version']\ndef is_experimental_header(h):\n    return ('experimental/' in h) or ('ext/' in h)\ndef is_support_header(h):\n    return '__support/' in h\nclass FileEntry:\n    def __init__(self, includes, individual_linecount):\n        self.includes = includes\n        self.individual_linecount = individual_linecount",
        "detail": "src.libcxx.utils.graph_header_deps",
        "documentation": {}
    },
    {
        "label": "is_experimental_header",
        "kind": 2,
        "importPath": "src.libcxx.utils.graph_header_deps",
        "description": "src.libcxx.utils.graph_header_deps",
        "peekOfCode": "def is_experimental_header(h):\n    return ('experimental/' in h) or ('ext/' in h)\ndef is_support_header(h):\n    return '__support/' in h\nclass FileEntry:\n    def __init__(self, includes, individual_linecount):\n        self.includes = includes\n        self.individual_linecount = individual_linecount\n        self.cumulative_linecount = None  # documentation: this gets filled in later\n        self.is_graph_root = None  # documentation: this gets filled in later",
        "detail": "src.libcxx.utils.graph_header_deps",
        "documentation": {}
    },
    {
        "label": "is_support_header",
        "kind": 2,
        "importPath": "src.libcxx.utils.graph_header_deps",
        "description": "src.libcxx.utils.graph_header_deps",
        "peekOfCode": "def is_support_header(h):\n    return '__support/' in h\nclass FileEntry:\n    def __init__(self, includes, individual_linecount):\n        self.includes = includes\n        self.individual_linecount = individual_linecount\n        self.cumulative_linecount = None  # documentation: this gets filled in later\n        self.is_graph_root = None  # documentation: this gets filled in later\ndef list_all_roots_under(root):\n    result = []",
        "detail": "src.libcxx.utils.graph_header_deps",
        "documentation": {}
    },
    {
        "label": "list_all_roots_under",
        "kind": 2,
        "importPath": "src.libcxx.utils.graph_header_deps",
        "description": "src.libcxx.utils.graph_header_deps",
        "peekOfCode": "def list_all_roots_under(root):\n    result = []\n    for root, _, files in os.walk(root):\n        for fname in files:\n            if os.path.basename(root).startswith('__') or fname.startswith('__'):\n                pass\n            elif ('.' in fname and not fname.endswith('.h')):\n                pass\n            else:\n                result.append(root + '/' + fname)",
        "detail": "src.libcxx.utils.graph_header_deps",
        "documentation": {}
    },
    {
        "label": "build_file_entry",
        "kind": 2,
        "importPath": "src.libcxx.utils.graph_header_deps",
        "description": "src.libcxx.utils.graph_header_deps",
        "peekOfCode": "def build_file_entry(fname, options):\n    assert os.path.exists(fname)\n    def locate_header_file(h, paths):\n        for p in paths:\n            fullname = p + '/' + h\n            if os.path.exists(fullname):\n                return fullname\n        if options.error_on_file_not_found:\n            raise RuntimeError('Header not found: %s, included by %s' % (h, fname))\n        return None",
        "detail": "src.libcxx.utils.graph_header_deps",
        "documentation": {}
    },
    {
        "label": "transitive_closure_of_includes",
        "kind": 2,
        "importPath": "src.libcxx.utils.graph_header_deps",
        "description": "src.libcxx.utils.graph_header_deps",
        "peekOfCode": "def transitive_closure_of_includes(graph, h1):\n    visited = set()\n    def explore(graph, h1):\n        if h1 not in visited:\n            visited.add(h1)\n            for h2 in graph[h1].includes:\n                explore(graph, h2)\n    explore(graph, h1)\n    return visited\ndef transitively_includes(graph, h1, h2):",
        "detail": "src.libcxx.utils.graph_header_deps",
        "documentation": {}
    },
    {
        "label": "transitively_includes",
        "kind": 2,
        "importPath": "src.libcxx.utils.graph_header_deps",
        "description": "src.libcxx.utils.graph_header_deps",
        "peekOfCode": "def transitively_includes(graph, h1, h2):\n    return (h1 != h2) and (h2 in transitive_closure_of_includes(graph, h1))\ndef build_graph(roots, options):\n    original_roots = list(roots)\n    graph = {}\n    while roots:\n        frontier = roots\n        roots = []\n        for fname in frontier:\n            if fname not in graph:",
        "detail": "src.libcxx.utils.graph_header_deps",
        "documentation": {}
    },
    {
        "label": "build_graph",
        "kind": 2,
        "importPath": "src.libcxx.utils.graph_header_deps",
        "description": "src.libcxx.utils.graph_header_deps",
        "peekOfCode": "def build_graph(roots, options):\n    original_roots = list(roots)\n    graph = {}\n    while roots:\n        frontier = roots\n        roots = []\n        for fname in frontier:\n            if fname not in graph:\n                graph[fname] = build_file_entry(fname, options)\n                graph[fname].is_graph_root = (fname in original_roots)",
        "detail": "src.libcxx.utils.graph_header_deps",
        "documentation": {}
    },
    {
        "label": "get_friendly_id",
        "kind": 2,
        "importPath": "src.libcxx.utils.graph_header_deps",
        "description": "src.libcxx.utils.graph_header_deps",
        "peekOfCode": "def get_friendly_id(fname):\n    i = fname.index('include/')\n    assert(i >= 0)\n    result = fname[i+8:]\n    return result\ndef get_graphviz(graph, options):\n    def get_decorators(fname, entry):\n        result = ''\n        if entry.is_graph_root:\n            result += ' [style=bold]'",
        "detail": "src.libcxx.utils.graph_header_deps",
        "documentation": {}
    },
    {
        "label": "get_graphviz",
        "kind": 2,
        "importPath": "src.libcxx.utils.graph_header_deps",
        "description": "src.libcxx.utils.graph_header_deps",
        "peekOfCode": "def get_graphviz(graph, options):\n    def get_decorators(fname, entry):\n        result = ''\n        if entry.is_graph_root:\n            result += ' [style=bold]'\n        if options.show_individual_line_counts and options.show_cumulative_line_counts:\n            result += ' [label=\"%s\\\\n%d indiv, %d cumul\"]' % (\n                get_friendly_id(fname), entry.individual_linecount, entry.cumulative_linecount\n            )\n        elif options.show_individual_line_counts:",
        "detail": "src.libcxx.utils.graph_header_deps",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.libcxx.utils.run",
        "description": "src.libcxx.utils.run",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--execdir', type=str, required=True)\n    parser.add_argument('--codesign_identity', type=str, required=False, default=None)\n    parser.add_argument('--env', type=str, nargs='*', required=False, default=dict())\n    parser.add_argument(\"command\", nargs=argparse.ONE_OR_MORE)\n    args = parser.parse_args()\n    commandLine = args.command\n    # HACK:\n    # If an argument is a file that ends in `.tmp.exe`, assume it is the name",
        "detail": "src.libcxx.utils.run",
        "documentation": {}
    },
    {
        "label": "ssh",
        "kind": 2,
        "importPath": "src.libcxx.utils.ssh",
        "description": "src.libcxx.utils.ssh",
        "peekOfCode": "def ssh(args, command):\n    cmd = ['ssh', '-oBatchMode=yes']\n    if args.extra_ssh_args is not None:\n        cmd.extend(shlex.split(args.extra_ssh_args))\n    return cmd + [args.host, command]\ndef scp(args, src, dst):\n    cmd = ['scp', '-q', '-oBatchMode=yes']\n    if args.extra_scp_args is not None:\n        cmd.extend(shlex.split(args.extra_scp_args))\n    return cmd + [src, '{}:{}'.format(args.host, dst)]",
        "detail": "src.libcxx.utils.ssh",
        "documentation": {}
    },
    {
        "label": "scp",
        "kind": 2,
        "importPath": "src.libcxx.utils.ssh",
        "description": "src.libcxx.utils.ssh",
        "peekOfCode": "def scp(args, src, dst):\n    cmd = ['scp', '-q', '-oBatchMode=yes']\n    if args.extra_scp_args is not None:\n        cmd.extend(shlex.split(args.extra_scp_args))\n    return cmd + [src, '{}:{}'.format(args.host, dst)]\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--host', type=str, required=True)\n    parser.add_argument('--execdir', type=str, required=True)\n    parser.add_argument('--tempdir', type=str, required=False, default='/tmp')",
        "detail": "src.libcxx.utils.ssh",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.libcxx.utils.ssh",
        "description": "src.libcxx.utils.ssh",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--host', type=str, required=True)\n    parser.add_argument('--execdir', type=str, required=True)\n    parser.add_argument('--tempdir', type=str, required=False, default='/tmp')\n    parser.add_argument('--extra-ssh-args', type=str, required=False)\n    parser.add_argument('--extra-scp-args', type=str, required=False)\n    parser.add_argument('--codesign_identity', type=str, required=False, default=None)\n    parser.add_argument('--env', type=str, nargs='*', required=False, default=dict())\n    parser.add_argument(\"command\", nargs=argparse.ONE_OR_MORE)",
        "detail": "src.libcxx.utils.ssh",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.libcxx.utils.sym_diff",
        "description": "src.libcxx.utils.sym_diff",
        "peekOfCode": "def main():\n    parser = ArgumentParser(\n        description='Extract a list of symbols from a shared library.')\n    parser.add_argument(\n        '--names-only', dest='names_only',\n        help='Only print symbol names',\n        action='store_true', default=False)\n    parser.add_argument(\n        '--removed-only', dest='removed_only',\n        help='Only print removed symbols',",
        "detail": "src.libcxx.utils.sym_diff",
        "documentation": {}
    }
]